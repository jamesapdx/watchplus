#!/usr/bin/python
# pylint: disable=line-too-long, missing-docstring , attribute-defined-outside-init, too-many-lines, fixme
# pylint: disable=invalid-name, no-else-return, redifined-outer-name, too-many-statements, bare-except
from __future__ import print_function

# -*- encoding: utf8 -*-

__version__ = "1.0"
__version_date__ = "05/27/21"

#################################################################################################################
#  watchplus, created by Jim Shaffer
#
#  usage: watchplus -h (view sample_run_file to see example)
#         to test out: watchplus -f sample_command_file (then ctrl-h to key mappings, switch tabs 1-0 & shift-1-0)
#
#  Python 2 and 3 compatible, Linux only, tested on Fedora
#
#  under the hood:
#       - watchplus extensively uses multiprocessing.
#       - class Settings stores all the commands to be run and settings as class variables.
#       - class Main() is responsible for starting all the processes.
#       - class FrameController (FC) is started as a new process, one per tab/command.  It stores the frame data
#         and draws the frames.
#           - class FrameGenerator is started as a process from a FC, it runs the actual linux command and sends
#             it back to the FC.
#       - class EventController is also started as it's own processes and sends events to the FC. It handles
#         new frame timing (so that all tabs stay in sync) and keystrokes (user interactions).
#################################################################################################################

import os
import sys
import subprocess
import multiprocessing
import threading
import time
import timeit
import datetime
import argparse
import traceback
import bisect
import string
import shlex
import fcntl
import bz2
import gzip
from time import sleep as _sleep

try:
    # sys.intern() in python3, just intern() in python2
    from sys import intern
except ImportError:
    pass
try:
    # sys.exc_clear in python2, not python3. don't really need it in python3
    from sys import exc_clear  # pylint: disable= unused-import
except ImportError:
    throw_away = lambda *args, **kwargs: 1
    sys.exc_clear = throw_away
try:
    import curses
except ImportError:
    print("Unable to load python-curses. You may need to install the package on the OS (yum install python-curses).")
    sys.exit()
try:
    # python 2 import cpickle, python 3 already cpickle
    import cPickle as pickle
except ImportError:
    import pickle


# ======================================================================================================================
#   Arguments and flags
# ======================================================================================================================

MAX_COMMANDS = 20
MAX_LINE_LENGTH = 10000  # number of characters on a line, will truncate if needed
MAX_TABS = 99
HELP_TAB = 90

def process_argparse():
    """ The main method for processing run arguments. Run watchplus -h for all the details.
    """
    # split all command line args based on -- only
    cl_argv_split = split_command_line_argv()

    # get command line command, divide into system args and command argss
    source = "command line"
    cl_system_args, cl_command_args = extract_system_command_args(cl_argv_split, source)

    # if -o (load saved run) do that only
    if cl_system_args.open:
        Settings.load_saved_run = True
        Settings.load_run_file = cl_system_args.open.name
        return

    # process -f file args
    f_system_args = []
    f_command_args = []
    if cl_system_args.arg_file:
        f_argv_split = read_file_args(cl_system_args.arg_file)

        # read command args and more system args from file if exists
        source = cl_system_args.arg_file.name
        f_system_args, f_command_args = extract_system_command_args(f_argv_split, source)

    # merge command line and file system args, command line system args take precedence over file system args
    system_args = merge_namespace(f_system_args, cl_system_args)

    # merge command line and file command args, file commands take precedence over command line commands, too confusing otherwise
    command_args = f_command_args + cl_command_args

    # assign to tabs
    commands_assigned, commands_unassigned = assign_commands_to_tabs(command_args)

    # validate args
    validate_args(system_args, commands_assigned)

    # print commands to screen (turned off)
    print_commands(commands_assigned, commands_unassigned)

    # store in settings
    store_args_in_settings(system_args, commands_assigned, commands_unassigned)

def merge_namespace(first, precedence):
    if first and precedence:
        new = vars(first)
        new.update(vars(precedence))
        return argparse.Namespace(**new)
    return first if first else precedence

def split_command_line_argv():
    argv_split = [[]]
    for argv in sys.argv[1:]:
        # split into command groups based on --, it's the only way argparse can handle it
        if argv == "-h" or argv == "--help":
            print_help()
            sys.exit()
        elif argv == "--":
            argv_split.append([])
        elif argv.startswith("-") and argv in argv_split[-1]:
            message = "duplicate {}, perhaps missing '--' separator".format(argv)
            raise argparse.ArgumentError(None, message)
        else:
            argv_split[-1].append(argv)

    return argv_split

def extract_system_command_args(argv_split, source):
    """ Extract the system and command args and return them as a Namespace object.

    :return: system_args = argparse.Namespace
             command_args = [argparse.Namespace,...]
    """
    system_args = None
    command_args = []

    # strip out system options as an argparse.Namespace
    parser = init_system_parser()
    add_system_args(parser)
    namespace = None
    for count, argv in enumerate(argv_split):
        arg = parser.parse_known_args(args=argv, namespace=namespace)
        system_args = arg[0]
        # namspace is used to preserve "running total" of sys args
        namespace = system_args
        argv_split[count] = arg[1]

    # convert to argparse.Namespace objects
    for argv in argv_split:
        if argv:
            parser = init_command_parser()
            add_command_args(parser)
            command_args.append(parser.parse_args(args=argv))
            command_args[-1].source = source
            command_args[-1].original = argv

    return system_args, command_args

def read_file_args(arg_file_object):
    argv_split = []
    with arg_file_object as f:
        for line in f:
            argv_split.append(shlex.split(line, comments=True))
    argv_split = list(filter(len, argv_split))
    return argv_split

def assign_commands_to_tabs(command_args):
    """ Assign the commands to tabs, first if there is a -t <num>, then just by order in the list.

    :return: [argparse.Namespace,...] note: can contain None values throughout because of manual -f assignment
    """
    tab_text = {1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '0',
                11: 'shift-1', 12: 'shift-2', 13: 'shift-3', 14: 'shift-4', 15: 'shift-5', 16: 'shift-6',
                17: 'shift-7', 18: 'shift-8', 19: 'shift-9', 20: 'shift-0'}
    commands_assigned = [None] * MAX_COMMANDS
    commands_temp = []
    commands_unassigned = []

    # assign to tab commands with -t option and put all remaining in commands_temp
    for command in command_args:
        tab = command.tab
        if tab and tab > 0 and tab <= MAX_COMMANDS:
            if not commands_assigned[tab - 1]:
                command.tab_label = tab_text[tab]
                commands_assigned[tab - 1] = command
                continue
        commands_temp.append(command)

    # add remaining to assigned and unassigned as argparse.Namespace
    for command in commands_temp:
        for count, tab in enumerate(commands_assigned):
            if not tab:
                command.tab_label = tab_text[count + 1]
                commands_assigned[count] = command
                break
        else:
            commands_unassigned.append(command)

    for count, command in enumerate(commands_assigned):
        if command:
            p = "tab {:8}: {} from {}"
            commands_assigned[count].print = p.format(tab_text[count + 1], command.original, command.source)
    for count, command in enumerate(commands_unassigned):
        p = "exceeded {} cmds, not using {} from {}"
        commands_unassigned[count].print = p.format(MAX_COMMANDS, command.original, command.source)

    return commands_assigned, commands_unassigned

def print_commands(commands_assigned, commands_unassigned, print_to_screen=False):
    if print_to_screen:
        for command in commands_assigned:
            if command:
                print(command.print)
        for command in commands_unassigned:
            print(command.print)

def validate_args(system_args, commands_assigned):
    if not [c for c in commands_assigned if c]:
        message = "No commands found."
        raise argparse.ArgumentError(None, message)

    if system_args.interval < .01:
        raise argparse.ArgumentError(None, "Interval cannot be less than .01.")

def store_args_in_settings(system_args, commands_assigned, commands_unassigned):
    Settings.interval = system_args.interval
    Settings.timeout = min(.1, Settings.interval * .4)
    Settings.precision = system_args.precision
    Settings.run_path = os.path.expanduser('~/')
    Settings.run_compression = "gzip"  # none|gzip|bz2. bz2 smaller file size but can not append with Python 2
    Settings.max_line_length = MAX_LINE_LENGTH

    for count, command in enumerate(commands_assigned):
        if command:
            Settings.commands[count] = vars(command)["\"cmd\""]
            Settings.commands_assigned.append(command.print)
            Settings._frame_controller_seeds[count] = FrameControllers()
            Settings.bottom_bar_tab_label[count] = command.tab_label
            Settings.bottom_bar_label[count] = "".join([x for x in Settings.commands[count] if x in Settings.printable])
            Settings.tab_ids.append(count)
            Settings.streaming[count] = command.streaming
            Settings.glue_bottom[count] = command.glue_bottom
            Settings.no_change[count] = command.no_change
            Settings.no_line_wrap[count] = command.no_line_wrap
            Settings.green_text[count] = command.green_text
    Settings.start_tab_id = Settings.tab_ids[0]
    for command in enumerate(commands_unassigned):
        Settings.commands_unassigned.append(command.print)

    Settings._setup_help()

def print_help(stdout=True):
    parser = init_system_parser()
    add_system_args(parser)
    add_command_args(parser)
    if stdout:
        parser.print_help()
    else:
        return parser.format_help()

def init_system_parser():
    try:
        terminal_width = int(run_linux("tput cols")[0])
    except ValueError:
        terminal_width = 120
    format_func = lambda prog: argparse.RawTextHelpFormatter(prog, width=terminal_width - 2, max_help_position=32)
    usage = "%(prog)s [-o <f>] | [-f <f>] | [sys options] [cmd options] \"cmd\" [ -- [cmd options] \"cmd\" ]..."
    description = "%(prog)s - a better watch. Featuring pause, rewind and forward, scrolling up and down, line " \
    "wrapping, multiple tabs running individual commands simultaneously, and saving runs. Also supports " \
    "streaming commands such as ping and tcpdump."
    epilog = """
Keys controlling playback and viewing:
  Playback controls (all tabs at once):
     Space ............................... Play | Pause  (does not stop recording)
     r ................................... Start | Stop recording Frames
     A a s | d f F ....................... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     Left | Right Arrows (ctrl, shift) ... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     w | e ............................... First << >> Last  Frames
  Viewing controls:
     1-0, shift 1-0 ...................... Change tab
                                           1-0 = tab 1-10, shft-1-0 = tab 11-20
     k j ................................. Up | Down
     Up | Down Arrows .................... Up | Down
     Ctrl-u | Ctrl-d ..................... Half page up | down
     Ctrl-b | Ctrl-f ..................... Page up | down
     Page-Up | Page-Down ................. Page up | down
     g | G ............................... Top | Bottom
     x ................................... Toggle change history display on/off
     l ................................... Toggle line wrap
     ctrl-g .............................. Toggle green text
  Other controls:
     ctrl-w .............................. Write frames and tabs to ~/[date_time].wp
                                           Stops recording during write. Load: -o <f>
     ctrl-h .............................. View this help and tab assignments
     ctrl-c | q .......................... Quit"""

    return argparse.ArgumentParser(formatter_class=format_func,
                                   description=description,
                                   usage=usage,
                                   epilog=epilog,
                                   add_help=False)

def init_command_parser():
    return argparse.ArgumentParser()

def add_system_args(parser):
    group = parser.add_argument_group("Run file")
    group.add_argument("-o", "--open", dest="open", type=argparse.FileType('r'), metavar="<f>",
                       help="Load %(prog)s run file <f> that was saved from a past run.\n"
                            "Use ctrl-w after a run to save to a run file.")

    group = parser.add_argument_group("Setup File")
    group.add_argument("-f", "--file", dest="arg_file", type=argparse.FileType('r'), metavar="<f>",
                       help="Read [sys options] [cmd options] \"cmd\" from file <f>.\n"
                            "One command per line. Example:\n-n 1 -p\n\"dmesg\"\n-s \"ping -4 1.1.1.1\"")

    group = parser.add_argument_group("System options (applies to all tabs)")
    group.add_argument("-n", "--interval", dest="interval", type=float, metavar="<s>", default=1.0,
                       help="Interval in <seconds>, minimum .01, default = 1.0.")
    group.add_argument("-p", "--precise", dest="precision", action="store_true",
                       help="Attempt to maintain interval, drop frame if not completed in time.")
    group.add_argument('-v', '--version', action='version',
                       version='%(prog)s version {} ({})'.format(__version__, __version_date__),
                       help="Show version number.")
    group.add_argument("-h", "--help", dest="show_help", action="store_true",
                       help="Show this help.")

def add_command_args(parser):
    group = parser.add_argument_group("Tab/Command options")
    group.add_argument("--", dest="separator", action="store_true",
                       help="Separator for commands on command line. Not needed for the first one.\n"
                            "Example: %(prog)s -n 1 \"dmesg\" -- -s \"ping -4 1.1.1.1\" -- \"nstat\"")
    group.add_argument("-s", "--streaming", dest="streaming", action="store_true",
                       help="Use with continual streaming commands such as tcpdump and ping.")
    group.add_argument("-b", "--bottom", dest="glue_bottom", action="store_true",
                       help="Start this tab at the bottom of the output, similar to follow option.")
    group.add_argument("-x", "--change", dest="no_change", action="store_true",
                       help="Do not display change history. Can be toggled on/off with 'x'.")
    group.add_argument("-l", "--line_wrap", dest="no_line_wrap", action="store_true",
                       help="Disable line wrap. Can be toggled on/off with 'l'.")
    group.add_argument("-g", "--green", dest="green_text", action="store_true",
                       help="Use green text.")
    group.add_argument("-t", "--tab", dest="tab", type=int, metavar="<t>",
                       help="Assign this command to tab <t> if possible, 1-{}.\n".format(MAX_COMMANDS))
    group.add_argument("\"cmd\"", help="Command to be run, up to {} allowed, each in in a separate tab.\n"
                                       "Note: enclose in DOUBLE quotes with inside escaped quotes as needed.".
                       format(MAX_COMMANDS))

class Settings(object):
    # tab/command settings (mostly from argparse)
    printable = string.digits + string.punctuation + string.ascii_letters + " "
    commands = [None] * MAX_TABS
    _frame_controller_seeds = [None] * MAX_TABS
    commands_assigned = [None]
    commands_unassigned = []
    bottom_bar_tab_label = [None] * MAX_TABS
    bottom_bar_label = [None] * MAX_TABS
    text = [None] * MAX_TABS
    streaming = [False] * MAX_TABS
    glue_bottom = [False] * MAX_TABS
    no_change = [False] * MAX_TABS
    no_line_wrap = [False] * MAX_TABS
    green_text = [False] * MAX_TABS
    random_text_colors = [False] * MAX_TABS

    # general and system settings
    tab_ids = []
    interval = 1
    timeout = .4
    precision = False
    start_tab_id = 0
    run_path = ""
    # TODO switch to bz2 on Python3
    run_compression = "gzip"  # none|gzip|bz2. bz2 smaller file size but can not append with Python 2
    max_line_length = MAX_LINE_LENGTH
    load_saved_run = False
    load_run_file = ""
    saved_frame_count = 0
    _python_version = sys.version_info[0]
    imported_python_version = sys.version_info[0]
    _version = __version__
    imported_version = __version__
    _compatable_versions = ["1.0"]
    # TODO add version checking on imports

    @classmethod
    def _setup_help(cls):
        if not hasattr(cls, "tab_id_help"):
            cls.tab_id_help = HELP_TAB
            cls.tab_ids.append(cls.tab_id_help)
        cls.text[cls.tab_id_help] = "\n" + print_help(stdout=False)
        cls.commands[cls.tab_id_help] = "Help Screen"
        cls.bottom_bar_tab_label[cls.tab_id_help] = "ctrl-h"
        cls.bottom_bar_label[cls.tab_id_help] = "Help Screen"
        cls._frame_controller_seeds[cls.tab_id_help] = FrameControllersHelp()
        cls.no_line_wrap[cls.tab_id_help] = False
        cls.no_change[cls.tab_id_help] = True
        cls.glue_bottom[cls.tab_id_help] = False

    @classmethod
    def __getstate__(cls):
        # picke does not handle class variables. this is needed to pickle class variables. Skip private variables
        # and methods any variable and methods that should not be including in saved runs should be private
        # with _ in front
        return {var_name: cls.__dict__[var_name] for var_name in cls.__dict__ if not var_name.startswith("_")}

    @classmethod
    def __setstate__(cls, state):
        for var_name, value in state.items():
            setattr(cls, var_name, value)

class Debug():
    """ Place Debug.debug_to_file(message, message, etc.) anywhere message will be output to debug_file.
    decorate a method with @Debug.debug_timer the time will be recorded to debug_file.
    """
    debug_file = "debug"

    @classmethod
    def debug_to_file(cls, *message):
        # enhance: change this to logging
        with open(cls.debug_file, "a") as f:
            for item in message:
                f.write(str(item) + " ")
            f.write(" \n")

    @classmethod
    def debug_timer(cls, func):
        # decorate a method with @Debug.debug_timer
        def wrapper_timer(*args, **kwargs):
            start = timeit.default_timer()
            func(*args, **kwargs)
            stop = timeit.default_timer()
            cls.debug_to_file(func.__name__, " time to complete: ", stop - start)
            # print(func.__name__, " time to complete: ", stop - start)
            return func(*args, **kwargs)
        return wrapper_timer


# ======================================================================================================================
#   Frame Controller, drawing the output, moving around, switching tabs
# ======================================================================================================================

class FrameControllers(object):
    """ This is the main controlling class.

        Frames are merely the collection of the stdout (or stderr) of the target command or script. If the target
        command or script is run every second for 10 seconds, 10 frames (outputs) will be generated and stored.
        Heatmaps are numerical representation for the change state of each character in a frame, it's the highlighting
        that occurs when a character changes from one frame to the next. See the FrameGenerators class for more details.

        This class is utilized inside a multiprocess subprocess, one subprocess for each target command or script.

        Class data can only be accessed from within the subprocess, multiprocess queues are utilized to share data
        between processes.
    """

    def __getstate__(self):
        """ Defines a custom field list to be used when pickling.

        :return: instance.__dict__ with only the includes fields
        """
        includes = [
            "lines_chars",
            "lines_chars_pointers",
            "lines",
            "lines_states",
            "lines_pointers",
            "lines_lengths",
            "frame_length",
            "frame_state",
            "frame_date_time",
            "current",
            "streaming"]
        return {var_name: self.__dict__[var_name] for var_name in self.__dict__ if var_name in includes}

    def __setstate__(self, state):
        """ Loads in pickle data, just the fields from __getstate__.

        :param state: this is provided by the pickle import
        """
        self.__dict__.update(state)

    def init_common(self):
        self.event = None
        self.max_line_length = Settings.max_line_length
        self.max_line_length_message = " ...MAX LINE LENGTH EXCEEDED ({})!!".format(self.max_line_length)
        self.max_line_length_total = len(self.max_line_length_message) + self.max_line_length

        # tab fields
        self.tab_active_tab = False
        self.draw_height_adder = 0
        self.draw_width_adder = 0
        self.terminal_draw_height = 0
        self.terminal_draw_width = 0
        self.curses_window = None
        self.terminal_height = 0
        self.terminal_width = 0
        self.y_top_line = 0
        self.y_top_num_wrapped_lines = 0
        self.draw_move = 0
        # non-live playback is a always 1 second.
        self.playback_speed = 1
        self.next_playback = 0
        self.next_frame_type = "first"
        self.next_heatmap_type = "first"

    def init_frame(self):
        # frame fields
        self.lines_chars = []
        self.lines_chars_pointers = []
        self.lines = []
        self.lines_states = []
        self.lines_pointers = []
        self.lines_lengths = []
        self.frame_length = []
        self.frame_state = []
        self.frame_date_time = []
        self.current = 0

        self.draw_current = 0
        self.draw_state = "stop"
        self.recording_state = "record"

    def init_frame_saved(self):
        self.current = len(self.frame_state) - 1
        self.draw_current = self.current
        self.draw_state = "pause"
        self.recording_state = "stop"

    def init_start_tab(self):
        if self.tab_id == Settings.start_tab_id:
            self.tab_active_tab = True
            self.draw_state = "live"

    def init_start_tab_saved(self):
        if self.tab_id == Settings.start_tab_id:
            self.tab_active_tab = True
            self.frame_draw_current_queue.value = self.draw_current
            self.frame_draw_state_queue.value = 0  # "pause": 0, "play": 1, "live": 2

    def init_curses_window(self):
        # create a new curses window

        # standard settings
        self.curses_window = curses.newwin(0, 0)
        self.curses_window.nodelay(1)
        self.curses_window.keypad(True)
        # these two might help with screen flicker
        self.curses_window.idcok(False)
        self.curses_window.idlok(False)
        self.curses_window.erase()
        # curses needs an initial write or it draws the first frame with artifacts
        for i in range(200):
            self.curses_window.addstr(" ")
        self.curses_window.redrawwin()
        self.curses_window.refresh()

    def init_event(self):
        self.event_choices = {
            # frames
            "start new frame": self.new_frame_request,  # comes from event controller self.event_queue
            "new frame": self.new_frame_received,  # comes from frame generator self.event_queue
            # tabs
            "tab change": self.change_tabs,
            "refresh": self.draw_live_frame,
            "back": self.frames_back,
            "forward": self.frames_forward,
            "tab move": self.move_tab_up_down,
            # toggle items
            "toggle draw state": self.toggle_draw_state,
            "toggle recording": self.toggle_recording,
            "toggle line wrap": self.toggle_line_warp,
            "toggle green": self.toggle_green,
            "toggle change": self.toggle_change,
            "clear history": self.clear_history,
            # save
            "save": self.write_to_file}

    def init_generator_childprocess(self):
        self.process_generator = None
        self.generator_seed = FrameGenerators()
        self.generator_frame_queue = multiprocessing.Queue(0)
        self.generator_event_queue = multiprocessing.Queue(0)
        self.process_generator = multiprocessing.Process(
            target=self.generator_seed.generator_controller,
            args=(
                self.command,
                self.generator_frame_queue,
                self.generator_event_queue,
                self.event_queue,
                self.streaming
            ))
        self.process_generator.start()

    def frame_controller(self, tab_id, event_queue, system_queue, frame_draw_current_queue, frame_draw_state_queue):
        """ This is the main method that controls storing and drawing frames. First, it spawns a never
            ending generator subprocesses that builds the frames.  The generator sends the data back
            through queues, which is then stored and drawn.
               generator           --> | event queue  | (let's us know a new frame is available)
               generator.new_frame --> | frame_queue  | --> self.frame  (the frame itself
            """
        try:
            # init mandatory settings
            self.command = Settings.commands[tab_id]
            self.tab_id = tab_id
            self.event_queue = event_queue
            self.system_queue = system_queue
            self.frame_draw_current_queue = frame_draw_current_queue
            self.frame_draw_state_queue = frame_draw_state_queue
            self.bottom_bar_tab_label = Settings.bottom_bar_tab_label[tab_id]
            self.bottom_bar_label = Settings.bottom_bar_label[tab_id]
            self.interval = Settings.interval
            self.streaming = Settings.streaming[tab_id]
            self.glued_to_bottom = True if self.streaming or Settings.glue_bottom[tab_id] else False
            self.no_change = Settings.no_change[tab_id]
            self.no_line_wrap = Settings.no_line_wrap[tab_id]
            self.green_text = Settings.green_text[tab_id]
            self.precision = False

            # init
            self.init_common()
            self.init_event()
            if Settings.load_saved_run:
                self.init_frame_saved()
                self.init_start_tab_saved()
                # get windows ready
                self.init_curses_window()
                self.get_terminal_size()
                if self.tab_active_tab:
                    # if saved, need time for all curses windows to load and then draw
                    time.sleep(.5)
                    self.draw_live_frame()
            else:
                self.init_frame()
                self.init_start_tab()
                self.init_generator_childprocess()
                # get windows ready
                self.init_curses_window()
                self.get_terminal_size()

            # tell event controller we are ready to go
            self.system_queue.put(1)

            # Start looping here
            self.main_loop()

        except:
            terminate_processes()

    def main_loop(self):
        timeout = min(.02, self.interval * .2)
        while True:
            # self.event expects a list, sent by another process
            try:
                # self.event is a list, [0] is the command, [1+] is options, see self.event_choices above
                self.event = self.event_queue.get(block=True, timeout=timeout)

            except multiprocessing.queues.Empty:
                self.playback()
            else:
                # run the appropriate self.event_choices function
                # an event can be from the event controller (new frame or keystrokes) or from child generator (new frame)
                self.event_choices.get(self.event[0], "")()

    # PROCESS FRAMES ######################

    def new_frame_request(self):
        # the event controller process tells all tabs it's time for a new event
        self.new_stop_time = self.event[1]
        self.new_start_time = self.event[2]
        self.precision = self.event[3]

        if len(self.frame_state) == 0:
            self.next_frame_type = "first"
            self.precision = False

        # request new frame from the child generator
        try:
            self.generator_event_queue.put([self.next_frame_type,
                                            self.new_stop_time,
                                            self.precision,
                                            self.terminal_draw_width], timeout=Settings.timeout)
            self.next_frame_type = "normal"
        except multiprocessing.queues.Full:
            pass

    def new_frame_received(self):
        self.new_frame_store()

        if self.draw_state == "live":
            self.draw_current = self.current

        self.draw_live_frame()
        # tell the event controller we are done adding a new frame
        self.system_queue.put(1)

    def new_frame_store(self):
        self.frame_state.append(self.event[1])
        self.frame_length.append(self.event[2])
        self.frame_date_time.append(self.new_start_time)

        self.current = len(self.frame_state) - 1

        new = self.current
        previous = max(0, new - 1)

        try:
            frame_changes, frame_line_numbers = self.generator_frame_queue.get(block=True, timeout=Settings.timeout)
        except multiprocessing.queues.Empty:
            # unable to get anything from the queue, just consider this an error and drop the frame
            self.frame_state[new] = "dropped"
            self.frame_length[new] = 0
        else:
            if self.frame_state[new] == "dropped":
                self.frame_length[new] = 0
            elif len(frame_changes) == 0:
                pass
            elif self.frame_state[new] == "first":
                # first frame ever, so easy store
                for line in frame_changes:
                    line_length = min(len(line), self.max_line_length_total)

                    if line_length > self.max_line_length:
                        self.lines.append([intern(line[:self.max_line_length]) + self.max_line_length_message])
                    else:
                        self.lines.append([intern(line)])

                    self.lines_pointers.append([0])
                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    # we store all chars changes and pointers for the yellow change history. Otherwise
                    # we would have to search all previous changed lines everytime we display a frame
                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])
            else:
                for counter, line_number in enumerate(frame_line_numbers):
                    line_length = min(len(frame_changes[counter]), self.max_line_length_total)

                    # truncate the line if too long
                    if line_length > self.max_line_length:
                        line = frame_changes[counter][:self.max_line_length] + self.max_line_length_message
                    else:
                        line = frame_changes[counter]

                    if line_number >= len(self.lines):
                        # must be a new line, longer than the existing output

                        self.lines.append([intern(line)])
                        # use a pointer, don't store the line over and over, future frames just access the pointer
                        self.lines_pointers.append([new])
                        # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                        self.lines_states.append([2])
                        # store the individual line length for use later
                        self.lines_lengths.append([line_length])

                        # we store all chars changes and pointers for the yellow change history. Otherwise
                        # we would have to search all previous changed lines everytime we display a frame
                        self.lines_chars.append([[char] for char in line])
                        self.lines_chars_pointers.append([[new] for x in range(line_length)])
                    else:
                        # this a change on an existing line in the output
                        self.lines[line_number].append(intern(line))
                        self.lines_pointers[line_number].append(new)
                        self.lines_lengths[line_number].append(line_length)
                        # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                        self.lines_states[line_number].append(1)

                        # we store all chars changes and pointers for the yellow change history. Otherwise
                        # we would have to search all previous changed lines everytime we display a frame
                        for column, char in enumerate(line):
                            if column >= len(self.lines_chars[line_number]):
                                self.lines_chars[line_number].append([char])
                                self.lines_chars_pointers[line_number].append([new])
                            elif column >= self.lines_lengths[line_number][-2]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            elif line_number >= self.frame_length[previous]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            else:
                                if self.lines_chars_pointers[line_number][column][-1] == 0:
                                    last_char = self.lines[line_number][0][column]
                                else:
                                    last_char = self.lines_chars[line_number][column][-1]
                                if last_char != char:
                                    self.lines_chars[line_number][column].append(char)
                                    self.lines_chars_pointers[line_number][column].append(new)

    # TOGGLE ITEMS ######################

    def toggle_recording(self):
        self.recording_state = self.event[1]
        if self.recording_state == "record":
            self.draw_current = self.current
            self.draw_state = "live"
        else:
            self.draw_state = "pause"
            if self.streaming:
                try:
                    self.generator_event_queue.put(["pause", None, None, self.terminal_draw_width],
                                                   timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        self.draw_live_frame()

    def toggle_change(self):
        if not self.no_change:
            self.no_change = True
        else:
            self.no_change = False
        self.draw_live_frame()

    def toggle_line_warp(self):
        if self.no_line_wrap:
            self.no_line_wrap = False
        else:
            self.no_line_wrap = True
        self.draw_live_frame()

    def toggle_green(self):
        if self.green_text:
            self.green_text = False
        else:
            self.green_text = True
        self.draw_live_frame()

    def toggle_draw_state(self):
        if self.draw_state == "play" or self.draw_state == "live":
            self.draw_state = "pause"
        else:
            if self.draw_current == self.current:
                self.draw_state = "live"
            else:
                self.draw_state = "play"
                self.next_playback = timeit.default_timer() + self.playback_speed
        self.draw_live_frame()

    def clear_history(self):
        # TODO clear history
        self.draw_live_frame()

    # DRAW FRAMES ######################

    def change_tabs(self):
        if self.event[2] == "new":
            # moving to this tab
            self.tab_active_tab = True

            self.draw_state = {0: "pause", 1: "play", 2: "live"}[self.frame_draw_state_queue.value]
            if self.draw_state == "play":
                self.next_playback = timeit.default_timer() + self.playback_speed
            elif self.draw_state == "live":
                self.draw_current = self.current
            else:
                self.draw_current = self.frame_draw_current_queue.value
                if self.draw_current > self.current:
                    self.draw_current = self.current
            self.draw_live_frame()
        else:
            # moving from this tab, pass items in the queue to the new tab
            self.tab_active_tab = False
            self.frame_draw_current_queue.value = self.draw_current
            self.frame_draw_state_queue.value = {"pause": 0, "play": 1, "live": 2}[self.draw_state]
            self.curses_window.refresh()

    def playback(self):
        if self.tab_active_tab and self.draw_state == "play" and timeit.default_timer() > self.next_playback:
            self.draw_current += 1
            if self.draw_current == self.current:
                self.draw_state = "live"
            self.draw_live_frame()
            self.next_playback = timeit.default_timer() + self.playback_speed

    def get_terminal_size(self):
        # need to refresh before getting size
        self.curses_window.refresh()
        self.terminal_height, self.terminal_width = self.curses_window.getmaxyx()

        self.terminal_draw_height = self.terminal_height - self.draw_height_adder
        self.terminal_draw_width = self.terminal_width - self.draw_width_adder

    def frames_back(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = 0
        else:
            self.draw_current = max(0, self.draw_current - amount)
        self.draw_state = "pause"
        self.draw_live_frame()

    def frames_forward(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = self.current
        else:
            self.draw_current = min(self.current, self.draw_current + amount)
        if self.draw_current == self.current:
            self.draw_state = "live"
        else:
            self.draw_state = "pause"
        self.draw_live_frame()

    def move_tab_up_down(self):
        self.get_terminal_size()
        direction = self.event[1]
        amount = self.event[2]

        if direction == "down":
            if amount == "one":
                self.draw_move = 1
            elif amount == "page":
                self.draw_move = self.terminal_draw_height
            elif amount == "half":
                self.draw_move = int(self.terminal_draw_height / 2)
            elif amount == "bottom":
                self.glued_to_bottom = True

        if direction == "up":
            self.glued_to_bottom = False
            if amount == "one":
                self.draw_move = -1
            elif amount == "half":
                self.draw_move = -int(self.terminal_draw_height / 2)
            elif amount == "page":
                self.draw_move = -self.terminal_draw_height
            elif amount == "top":
                self.y_top_line = 0
                self.y_top_num_wrapped_lines = 0

        self.draw_live_frame()

    def line_wrap_off(self):
        """ Handle tab movement here, using self.draw_move = +- lines.
        """
        self.y_top_num_wrapped_lines = 0
        if self.frame_length[self.draw_current] <= self.terminal_draw_height:
            pass
        elif self.glued_to_bottom:
            self.y_top_line = self.frame_length[self.draw_current] - self.terminal_draw_height
        elif self.draw_move < 0:
            self.y_top_line += self.draw_move
            self.y_top_line = max(0, self.y_top_line)
        elif self.draw_move > 0:
            self.y_top_line += self.draw_move
            self.y_top_line = min(self.frame_length[self.draw_current] - self.terminal_draw_height, self.y_top_line)

        self.draw_move = 0

    def line_wrap(self):
        """ Line wrap the frame to display, just the lines in the display range.
            Line wrapping is very complicated, must take into account glue_bottom, scrolling,
            terminal resizes, and more.  We could just let curses handle it, but it would only scroll
            an entire line at a time and not handle glue_bottom.

            Handle tab movement here, using self.draw_move = +- lines
        """
        draw_current = self.draw_current
        live = True if self.current == self.draw_current else False
        bottom = None

        wrapped_lines = []

        if self.glued_to_bottom:
            counter = 0
            start = max(0, self.frame_length[draw_current] - (2 * self.terminal_draw_height))
            start = self.frame_length[draw_current] - 1
            for line_number in range(start, -1, -1):
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    # TODO: grep / filter out items here
                    # if x not in self.lines[line_number]:
                    #    continue

                sub_lines = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                for sub_line in range(sub_lines + 1):
                    wrapped_lines.append([line_number, sub_line])
                    counter += 1

                if counter > self.terminal_draw_height + 1:
                    break

            wrapped_lines.reverse()

            if len(wrapped_lines) > self.terminal_draw_height:
                wrapped_top = len(wrapped_lines) - self.terminal_draw_height
            else:
                wrapped_top = 0
            self.y_top_line = wrapped_lines[wrapped_top][0]
            self.y_top_num_wrapped_lines = wrapped_lines[wrapped_top][1]
            wrapped_lines.reverse()
        else:
            if self.y_top_line < 0:
                self.y_top_line = 0
                self.y_top_num_wrapped_lines = 0
            elif self.y_top_line >= self.frame_length[draw_current]:
                self.y_top_line = self.frame_length[draw_current] - 1
                self.y_top_num_wrapped_lines = 0

            if self.y_top_num_wrapped_lines > 0:
                # the line may have shrunk on this frame and self.y_top_num_wrapped_liness may be to big, correct if needed
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[self.y_top_line], draw_current) - 1

                sub_lines = (self.lines_lengths[self.y_top_line][position] // self.terminal_draw_width)
                if self.y_top_num_wrapped_lines > sub_lines:
                    self.y_top_num_wrapped_lines = sub_lines

            if self.draw_move != 0:
                start = max(0, self.y_top_line - self.terminal_draw_height)
                end = min(self.frame_length[draw_current], self.y_top_line + (self.terminal_draw_height * 2))
                for line_number in range(start, end):
                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    sub_lines = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                    for sub_line in range(sub_lines + 1):
                        wrapped_lines.append([line_number, sub_line])

                    if line_number == self.frame_length[draw_current] - 1:
                        bottom = len(wrapped_lines) - 1

                wrapped_top = wrapped_lines.index([self.y_top_line, self.y_top_num_wrapped_lines])

                if self.draw_move < 0:
                    wrapped_top = max(0, wrapped_top + self.draw_move)
                else:
                    if len(wrapped_lines) > self.terminal_draw_height:
                        wrapped_top = min(len(wrapped_lines) - 1, wrapped_top + self.draw_move)
                        wrapped_bottom = min(len(wrapped_lines) - 1,
                                             wrapped_top + self.terminal_draw_height - 1)
                        wrapped_top = wrapped_bottom - self.terminal_draw_height + 1

                        if wrapped_bottom == bottom:
                            self.glued_to_bottom = True
                    else:
                        wrapped_top = 0
                        self.glued_to_bottom = True

                self.y_top_line = wrapped_lines[wrapped_top][0]
                self.y_top_num_wrapped_lines = wrapped_lines[wrapped_top][1]
        self.draw_move = 0

    def draw_live_frame(self):
        if not self.tab_active_tab:
            return

        # use this for status bar
        self.draw_height_adder = 1
        # use this for line numbers (future)
        self.draw_width_adder = 0
        self.get_terminal_size()

        draw_current = self.draw_current

        # # using .clear() cause screen flicker.  Use erase() with redrawwin() and refresh()
        self.curses_window.erase()

        if self.current < 0 or len(self.frame_state) == 0:
            status_bar, color_pair = self.status_bar_build()
        elif draw_current > self.current:
            # saving a run may result in uneven frame count across the tabs
            self.draw_current = self.current
            status_bar, color_pair = self.status_bar_build()
        elif self.frame_state[draw_current] == "dropped":
            if self.precision is True:
                self.curses_window.addstr("Command could not complete in time, frame dropped.")
            else:
                self.curses_window.addstr("Error processing frame, frame dropped.")
            status_bar, color_pair = self.status_bar_build()
        elif self.frame_length[draw_current] == 0:
            status_bar, color_pair = self.status_bar_build()
        else:

            if self.no_line_wrap:
                self.line_wrap_off()
            else:
                self.line_wrap()

            draw_start = self.y_top_line
            draw_end = min(self.frame_length[draw_current], self.y_top_line + self.terminal_draw_height)
            live = True if draw_current == self.current else False

            try:
                for line_number in range(draw_start, draw_end):
                    # we don't stare the same line over an over, we just store it once and retrieve the pointer
                    # to that line.  we need bisect to find last closet pointer to the frame
                    # we are drawing (draw_current). if we are live than we can just grab the last pointer at [-1]
                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1
                    pointer = self.lines_pointers[line_number][position]

                    line_start = 0
                    if self.no_line_wrap:
                        # cut the line short to term width
                        line = self.lines[line_number][position][:self.terminal_draw_width - 1]
                    else:
                        # long line, let curses wrap it for us
                        line = self.lines[line_number][position]
                        if line_number == self.y_top_line:
                            # top line, calculate this because of chopped wrap
                            line_start = self.y_top_num_wrapped_lines * self.terminal_draw_width
                    line_length = len(line)
                    line_state = self.lines_states[line_number][position]

                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    color_text = 4 if self.green_text else 0
                    if line_state == 0 or self.no_change:
                        # no change on "pointed to" line, or display changes turned off
                        self.curses_window.addstr(line[line_start:], curses.color_pair(color_text))
                    elif line_state == 2:
                        # change on new a new line (longer than previous output)
                        if pointer == draw_current:
                            # change on current frame, so use red
                            color = 2
                        else:
                            # change on older frame,so it is just a history, use yellow
                            color = 1
                        color_pair = curses.color_pair(color)
                        self.curses_window.addstr(line[line_start:], color_pair)
                    else:
                        # this line self line_state == 1, change on an existing "pointed to" line
                        for column in range(line_start, line_length):
                            try:
                                char = line[column]
                            except IndexError:
                                char = "?"

                            position = -1
                            if not live:
                                position = bisect.bisect(self.lines_chars_pointers[line_number][column], draw_current) - 1
                            pointer = self.lines_chars_pointers[line_number][column][position]

                            try:
                                color = color_text
                                if pointer == 0:
                                    # the first frame, so no change
                                    pass
                                elif pointer == draw_current:
                                    # the new char is on this frame, so change color is red
                                    color = 2
                                else:
                                    # the new char is an old frame, so yellow history
                                    color = 1
                            except (IndexError, ValueError):
                                pass
                            color_pair = curses.color_pair(color)

                            self.curses_window.addstr(char, color_pair)

                    self.curses_window.addstr("\n")

            except curses.error:
                pass

            status_bar, color_pair = self.status_bar_build(draw_start, draw_end, self.frame_length[draw_current])

        # draw status bar to curses
        line_number = self.terminal_height - 1
        for column in range(self.terminal_width - 1):
            # need the terminal_width -1 because of a curses bug, it sticks a \n on the end of the last line
            try:
                char = str(status_bar[column])
            except IndexError:
                char = " "
            self.curses_window.addstr(line_number, column, char, color_pair)
        self.curses_window.addstr(line_number, column, " ", color_pair)
        self.curses_window.insstr(line_number, column, " ", color_pair)

        self.curses_window.redrawwin()
        self.curses_window.refresh()

    def status_bar_build(self, draw_start=-1, draw_end=0, frame_height=0):
        try:
            date_time = self.frame_date_time[self.draw_current].strftime("%H:%M:%S.%f")
        except (AttributeError, IndexError):
            date_time = "--:--:--.---"

        # TODO stuck tab
        mode_text = {
            "waiting"      : ["Waiting", curses.color_pair(31)],
            "live play"    : ["<> LIVE    ", curses.color_pair(31)],
            "playback"     : [">> PLAYBACK", curses.color_pair(32)],
            "paused"       : ["|| PAUSED  ", curses.color_pair(33)],
            "stopped"      : [" (STOPPED) ", curses.color_pair(34)],
            "stuck"        : ["TAB X STUCK", curses.color_pair(34)],
            "none"         : [" ", curses.color_pair(33)]
        }

        if self.current < 0:
            mode = "waiting"
        elif self.recording_state == "stop":
            mode = "stopped"
        elif self.draw_state == "pause":
            mode = "paused"
        elif self.draw_state == "play":
            mode = "playback"
        elif self.draw_state == "live":
            mode = "live play"
        else:
            mode = "none"

        p = " {:>2} | {:.12} | {}/{} ( {}-{}/{} Lines ) | CH:{:3} LW:{:3} n:{:3} p:{} | TAB {}: {}"
        status_bar = p.format(
            date_time,
            mode_text[mode][0],
            max(0, self.draw_current + 1),
            max(0, self.current + 1),
            max(0, draw_start + 1),
            max(0, min(draw_end, frame_height)),
            frame_height,
            "OFF" if self.no_change else "ON",
            "OFF" if self.no_line_wrap else "ON",
            self.interval,
            "ON" if self.precision else "OFF",
            self.bottom_bar_tab_label,
            self.bottom_bar_label)

        return status_bar, mode_text[mode][1]

    def write_to_file(self):
        run_file = self.event[1]
        if not self.tab_id == Settings.tab_id_help:
            try:
                if Settings.run_compression == "gzip":
                    with gzip.GzipFile(run_file, 'ab') as f:
                        pickle.dump(self, f, protocol=2)
                elif Settings.run_compression == "bz2":
                    with bz2.BZ2File(run_file, 'XX') as f: # there is no 'ab' on bz2 on Python 2
                        pickle.dump(self, f, protocol=2)
                else:
                    with open(run_file, 'ab') as f:
                        pickle.dump(self, f, protocol=2)
            except FileNotFoundError:
                # TODO add failed message, remove started file
                # let's not crash the program!
                pass
            except:
                # TODO add failed message, remove started file
                # let's not crash the program!
                pass

        # tell the event controller we are done
        self.system_queue.put(2)


class FrameControllersStatic(FrameControllers):
    """ Run or display once and not again. use self.get_output() to control first frame output.
    """
    def init_frame_saved(self):
        # if saved, we need to create all frames manually (typically for help display)
        self.init_frame()
        super(FrameControllersStatic, self).init_frame_saved()
        for count in range(Settings.saved_frame_count + 1):
            self.new_frame_store()

    def init_generator_childprocess(self):
        pass

    def new_frame_request(self):
        self.new_frame_store()

        self.system_queue.put(1)

        if self.draw_state == "live":
            self.draw_current = self.current

        self.draw_live_frame()

    def new_frame_received(self):
        pass

    def new_frame_store(self):
        self.frame_state.append("unchanged")
        try:
            self.frame_date_time.append(self.event[2])
        except TypeError:
            self.frame_date_time.append("")


        self.current = len(self.frame_state) - 1

        if self.current == 0:

            frame = self.get_output()

            for line in frame:
                if line is not None:
                    line_length = len(line)

                    self.lines.append([intern(line)])
                    self.lines_pointers.append([0])
                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])

            self.frame_state[self.current] = ("first")
            self.frame_length.append(len(self.lines))
        else:
            # expects the length to be the same even if there are no changes
            self.frame_length.append(self.frame_length[0])

    def get_output(self):
        # return any list of strings, this will be the first frame
        frame = []
        return frame

    def toggle_change(self):
        pass

    def clear_history(self):
        pass


class FrameControllersHelp(FrameControllersStatic):

    def get_output(self):
        help = Settings.text[Settings.tab_id_help].splitlines()
        help += ["", "Tabs and Commands:"]
        help += ["      {}".format(x) for x in Settings.commands_assigned if x is not None]
        commands_unassigned = [x for x in Settings.commands_unassigned if x]
        if commands_unassigned:
            help += ["", "Unassigned Commands:"]
            help += ["      {}".format(x) for x in commands_unassigned if x]
        help = ["  {}".format(x) for x in help if x is not None]
        return help


class FrameControllersNoChange(FrameControllers):
    """ TODO future home of not recording changes for performance"""
    pass


# ======================================================================================================================
#   Frame Generator, running, reading, storing a command
# ======================================================================================================================

class FrameGenerators(object):

    def generator_controller(self, command, frame_queue, generator_event_queue, event_queue, streaming):
        try:
            self.frame = [[], []]
            self.frame_line_numbers = []
            self.frame_state = None
            self.frame_changes = []
            self.frame_length = [0, 0]
            self.frame_stream_length = 0
            self.terminal_draw_width = 0

            self.command = command
            self.frame_queue = frame_queue
            self.generator_event_queue = generator_event_queue
            self.event_queue = event_queue
            self.command_pid = None
            self.proc = None
            self.generator_event = None

            self.streaming = streaming
            self.precision = False
            self.current = 0
            self.last = 1
            self.frame_type = "first"
            self.stop_time = 0
            self.recording_state = "record"

            while True:
                # frame_controller sends us the parameters for this new frame
                self.generator_event = self.generator_event_queue.get(block=True)
                # self.frame_type = normal, full, first, stop, start
                self.frame_type = self.generator_event[0]
                self.stop_time = self.generator_event[1]
                self.precision = self.generator_event[2]
                self.terminal_draw_width = self.generator_event[3]

                if self.frame_type == "pause":
                    self.recording_state = "pause"
                    if self.streaming:
                        self.pause_pid(self.command_pid)
                        continue
                if self.streaming:
                    if self.recording_state == "pause":
                        self.continue_pid(self.command_pid)
                        self.recording_state = "record"
                    if self.frame_type == "first":
                        self.frame_generator_streaming_first()
                    self.frame_generator_streaming()
                else:
                    if self.recording_state == "pause":
                        self.recording_state = "record"
                    self.frame_generator()
                    self.frame_pre_change()
                    if self.precision is True and self.stop_time < timeit.default_timer():
                        self.dropped()

                self.put_queues()

        except:
            terminate_processes()

    def dropped(self):
        self.command_pid = 0
        self.frame_state = "dropped"
        self.frame_length[self.current] = 0
        self.frame_changes = []

    def pause_pid(self, pid):
        term_sig = 19
        pid = 0 if pid is None else pid
        try:
            os.kill(pid, term_sig)
        except OSError:
            pass

    def continue_pid(self, pid):
        term_sig = 18
        pid = 0 if pid is None else pid
        try:
            os.kill(pid, term_sig)
        except OSError:
            pass

    def terminate_pid(self, pid):
        term_sig = 15
        pid = 0 if pid is None else pid
        try:
            os.kill(pid, term_sig)
        except OSError:
            pass
        self.frame_state = "dropped"

    def run_command(self):
        env = dict(os.environ, COLUMNS=str(self.terminal_draw_width))

        proc = subprocess.Popen(
            self.command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            env=env,
            universal_newlines=True
        )
        self.command_pid = proc.pid

        return proc

    # Streaming Generator starts here ####################

    def frame_generator_streaming_first(self):
        self.proc = self.run_command()
        fl_out = fcntl.fcntl(self.proc.stdout, fcntl.F_GETFL)
        fl_err = fcntl.fcntl(self.proc.stderr, fcntl.F_GETFL)
        fcntl.fcntl(self.proc.stdout, fcntl.F_SETFL, fl_out | os.O_NONBLOCK)
        fcntl.fcntl(self.proc.stderr, fcntl.F_SETFL, fl_err | os.O_NONBLOCK)

    def frame_generator_streaming(self):
        safe_margin = .0001
        end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)
        time.sleep(end_timer)

        try:
            result = self.proc.stdout.read()
        except (TypeError, IOError):
            result = ""
        try:
            error = self.proc.stderr.read()
        except (TypeError, IOError):
            error = ""

        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()


        if self.frame_type == "first":
            self.frame_state = "first"
            self.frame_line_numbers = []
        elif not self.frame[self.current]:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []
        else:
            self.frame_state = "changed"
            self.frame_changes = self.frame[self.current]
            self.frame_line_numbers = list(
                range(self.frame_stream_length, self.frame_stream_length + len(self.frame[self.current])))

        self.frame_stream_length += len(self.frame[self.current])
        self.frame_length[self.current] = self.frame_stream_length

    # Non Streaming Generator starts here ####################

    def frame_generator(self):
        """ A frame is composed of a line by line list of the output from the assigned command for this curses_window.
        """
        self.proc = self.run_command()

        safe_margin = .0001
        if self.precision is True:
            end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)

            if end_timer > 0:
                timer = threading.Timer(end_timer, self.terminate_pid, args=(self.command_pid,))
                timer.start()

                result, error = self.proc.communicate()
                timer.cancel()
            else:
                # already missed our time before we even ran the command
                self.frame_state = "dropped"

            if self.frame_state == "dropped":
                self.dropped()
                return
        else:
            result, error = self.proc.communicate()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

        # TODO fix: improve stderr
        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = ""
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

    def frame_pre_change(self):
        self.frame_length[self.current] = len(self.frame[self.current])

        if self.frame_type == "first":
            self.frame_line_numbers = []
            self.frame_state = "first"
        elif self.frame_length[self.current] != self.frame_length[self.last]:
            self.frame_change()
        elif self.frame[self.current] != self.frame[self.last]:
            self.frame_change()
        else:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()

    def frame_change(self):
        self.frame_state = "changed"
        self.frame_changes = []
        self.frame_line_numbers = []
        for line_number, line in enumerate(self.frame[self.current]):
            try:
                if line != self.frame[self.last][line_number]:
                    self.frame_changes.append(line)
                    self.frame_line_numbers.append(line_number)
            except IndexError:
                self.frame_changes.append(line)
                self.frame_line_numbers.append(line_number)

    # Put queues #########################

    def put_queues(self):
        try:
            if self.frame_state == "first":
                self.frame_queue.put(
                    (self.frame[self.current], self.frame_line_numbers),
                    timeout=Settings.timeout)
            else:
                self.frame_queue.put(
                    (self.frame_changes, self.frame_line_numbers),
                    timeout=Settings.timeout)
        except multiprocessing.queues.Full:
            # missed the timout, that's ok, if nothing in the queue the receiver will just call it dropped
            pass

        self.event_queue.put([
            "new frame",
            self.frame_state,
            self.frame_length[self.current]])

        if self.frame_state != "dropped":
            if self.current == 0:
                self.current = 1
                self.last = 0
            else:
                self.current = 0
                self.last = 1


# ======================================================================================================================
#   Event Controller, key presses
# ======================================================================================================================

class EventController(object):

    def __init__(self):
        self.key_mapping()

    def event_controller(self, curses_window, event_queues, system_queues):
        try:
            self.curses_window = curses_window
            self.draw_tab_id = Settings.start_tab_id
            self.event_queues = event_queues
            self.system_queues = system_queues
            self.draw_tab_ids = Settings.tab_ids
            self.start_time = timeit.default_timer()
            self.precision = Settings.precision
            self.new_stop_time = 0
            self.new_start_date_time = 0
            self.done_count = 0
            self.help = False
            self.last_tab = self.draw_tab_id
            self.resize_request = 0
            self.recording_state = "stop" if Settings.load_saved_run else "record"

            # start here
            while True:
                # if step is too low performance will suffer
                step = min(.02, Settings.interval * .2)
                time.sleep(step)

                # we will give the tabs a stop time, tell them to start, wait to hear they all done, repeat
                # if precision = true they should finish on time
                if timeit.default_timer() > self.new_stop_time and self.recording_state == "record":
                    if self.done_count >= len(self.draw_tab_ids):
                        self.done_count = 0
                        self.new_stop_time = Settings.interval + timeit.default_timer()
                        self.new_start_date_time = datetime.datetime.now()

                        for tab_id in self.draw_tab_ids:
                            event_queues[tab_id].put(["start new frame",
                                                      self.new_stop_time,
                                                      self.new_start_date_time,
                                                      self.precision])
                    else:
                        for draw_tab_id in self.draw_tab_ids:
                            # collect "frame done" from the frame controllers
                            try:
                                x = int(self.system_queues[draw_tab_id].get(block=False))
                                self.done_count += 1 if x == 1 else 0
                            except multiprocessing.queues.Empty:
                                pass

                # when a curses_window is resized, a lot of events are fired once. We will delay a bit.
                if self.resize_request and timeit.default_timer() > self.resize_request:
                    try:
                        self.event_queues[self.draw_tab_id].put(["refresh"], block=False)
                        self.resize_request = 0
                    except multiprocessing.queues.Full:
                        pass

                # look for a keyboard input now
                self.keyboard_input()

        except:
            terminate_processes()

    def key_mapping(self):
        self.key_map = {
            ord(" ")          : ["one", "toggle draw state"],
            ord("l")          : ["one", "toggle line wrap"],
            7                 : ["one", "toggle green"],  # ctrl-g

            curses.KEY_LEFT   : ["one", "back", 1],  # left-arrow
            ord("s")          : ["one", "back", 1],
            393               : ["one", "back", 10],  # shf-left-arror
            ord("a")          : ["one", "back", 10],
            552               : ["one", "back", 100],  # alt-shf-left-arrow
            546               : ["one", "back", 100],  # ctrl-left-arrow
            ord("A")          : ["one", "back", 100],
            ord("w")          : ["one", "back", 0],

            curses.KEY_RIGHT  : ["one", "forward", 1],  # right-arrow
            ord("d")          : ["one", "forward", 1],
            402               : ["one", "forward", 10],  # shf-right-arrow
            ord("f")          : ["one", "forward", 10],
            567               : ["one", "forward", 100],  # alt-shf-right-arrow
            561               : ["one", "forward", 100],  # ctrl-right-arrow
            ord("F")          : ["one", "forward", 100],
            ord("e")          : ["one", "forward", 0],

            curses.KEY_DOWN   : ["one", "tab move", "down", "one"],
            ord("j")          : ["one", "tab move", "down", "one"],
            4                 : ["one", "tab move", "down", "half"],  # ctrl-d
            336               : ["one", "tab move", "down", "page"],  # shift-down
            curses.KEY_NPAGE  : ["one", "tab move", "down", "page"],  # page down
            6                 : ["one", "tab move", "down", "page"],  # ctrl-f
            ord("G")          : ["one", "tab move", "down", "bottom"],
            curses.KEY_END    : ["one", "tab move", "down", "bottom"],
            526               : ["one", "tab move", "down", "bottom"],  # ctrl-down

            curses.KEY_UP     : ["one", "tab move", "up", "one"],
            ord("k")          : ["one", "tab move", "up", "one"],
            21                : ["one", "tab move", "up", "half"],  # ctrl-u
            337               : ["one", "tab move", "up", "page"],  # shift-up
            curses.KEY_PPAGE  : ["one", "tab move", "up", "page"],  # page up
            2                 : ["one", "tab move", "up", "page"],  # ctrl-b
            ord("g")          : ["one", "tab move", "up", "top"],
            curses.KEY_HOME   : ["one", "tab move", "up", "top"],
            567               : ["one", "tab move", "up", "top"],  # ctrl-up

            ord("x")          : ["one", "toggle change"],
            ord("X")          : ["one", "clear history"]
        }
        self.tab_map = {ord("1"): 0, ord("2"): 1, ord("3"): 2, ord("4"): 3, ord("5"): 4, ord("6"): 5, ord("7"): 6,
                        ord("8"): 7, ord("9"): 8, ord("0"): 9, ord("!"): 10, ord("@"): 11, ord("#"): 12, ord("$"): 13,
                        ord("%"): 14, ord("^"): 15, ord("&"): 16, ord("*"): 17, ord("("): 18, ord(")"): 19,
                        8: Settings.tab_id_help}

    def keyboard_input(self, raw_keystroke=0):
        self.curses_window.nodelay(1)
        if raw_keystroke == 0:
            raw_keystroke = self.curses_window.getch()

        if raw_keystroke != -1:
            # to see keystroke codes uncomment the follow line and tail -f debug on the commond line
            Debug.debug_to_file("raw: {}".format(str(raw_keystroke)))
            pass

        if raw_keystroke == curses.KEY_RESIZE:
            # curses_window resize event occurred
            # when a curses_window is resized, a lot of events are fired once. We will delay a bit.
            # this also helps with redraw issues
            wait_time = .3
            self.resize_request = timeit.default_timer() + wait_time

        if self.draw_tab_id == Settings.tab_id_help:
            # when resizing, a lot of events are generated at once. wait a bit before sending
            if raw_keystroke == 8 or raw_keystroke == 27:
                # ctrl-h or [esc], toggle out of help. Fake a key press for the last tab
                raw_keystroke = [key for key, w_id in self.tab_map.items() if w_id == self.last_tab][0]

        if raw_keystroke in self.tab_map:
            # switch tabs
            new_win = self.tab_map[raw_keystroke]
            if Settings.commands[new_win] and new_win != self.draw_tab_id:
                try:
                    self.event_queues[self.draw_tab_id].put(("tab change", new_win, "close"), timeout=Settings.timeout)
                    self.last_tab = self.draw_tab_id
                    self.draw_tab_id = new_win
                    time.sleep(.1)
                    self.event_queues[self.draw_tab_id].put(("tab change", new_win, "new"), timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        if raw_keystroke == ord("r") and not Settings.load_saved_run:
            # stop / start recording
            if self.recording_state == "record":
                self.recording_state = "stop"
                self.key_map[ord("r")] = ["all", "toggle recording", "stop"]
                # give some time for frames to finish up
                time.sleep(.3)
            else:
                self.recording_state = "record"
                self.key_map[ord("r")] = ["all", "toggle recording", "record"]
                self.new_stop_time = 0

        if raw_keystroke in self.key_map:
            # move, frames, etc
            if self.key_map[raw_keystroke][0] == "all":
                win = self.draw_tab_ids
            else:
                win = [self.draw_tab_id]
            instruction = self.key_map[raw_keystroke][1:]

            self.send_event(instruction, win)

        if raw_keystroke == 23:
            # ctrl-w
            self.write_to_file()

        if raw_keystroke == ord("q"):
            sys.exc_clear()
            # need to simulate a ctrl-c, otherwise sleeping processes won't exit on 'q'
            term_sig = 2
            try:
                os.killpg(os.getpgid(0), term_sig)
            except OSError:
                pass

    def send_event(self, instruction, win):
        for tab_id in win:
            try:
                self.event_queues[tab_id].put(instruction, timeout=Settings.timeout)
            except multiprocessing.queues.Full:
                pass

    def write_to_file(self):
        # first need to stop recording
        temp_recording_state = self.recording_state
        if self.recording_state == "record":
            self.recording_state = "stop"
            self.send_event(["toggle recording", "stop"], self.draw_tab_ids)
            # give some time for frames to finish up
            time.sleep(.6)

        # make a filename
        file_base = str(datetime.datetime.now().date()) + "-" + \
                   str(datetime.datetime.now().time()).split(".")[0].replace(":", "-") + \
                   ".wp"
        filename = file_base
        add_count = 0
        while True:
            if os.path.exists("{}/{}".format(Settings.run_path, filename)):
                add_count += 1
                filename = file_base.replace(".wp", "_" + str(add_count) + ".wp")
                continue
            break
        run_file = "{}/{}".format(Settings.run_path, filename)

        # write Setting
        try:
            if Settings.run_compression == "gzip":
                with gzip.GzipFile(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
            elif Settings.run_compression == "gzip":
                with bz2.BZ2File(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
            else:
                with open(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
        except FileNotFoundError:
            # TODO add failed message, remove started file
            # let's not crash the program!
            return
        except:
            # TODO add failed message
            # let's not crash the program!
            return

        # tell each tab to write
        for tab_id in self.draw_tab_ids:
            self.send_event(["save", run_file], [tab_id])
            get = 0
            for i in range(3 * 60 * 10):
                # TODO improve this timeout, can cause a 3 minute delay if problems
                # get completed response(2), 3 minute timeout
                try:
                    get = int(self.system_queues[tab_id].get(block=True, timeout=.1))
                    self.done_count += 1 if get == 1 else 0
                    if get == 2:
                        break
                except multiprocessing.queues.Empty:
                    pass
            if get != 2:
                # TODO add failed message
                return

        # turn recording back on
        if temp_recording_state == "record":
            self.recording_state = "record"
            self.new_stop_time = 0
            self.send_event(["toggle recording", "record"], self.draw_tab_ids)

# ======================================================================================================================
#   Functions
# ======================================================================================================================

def new_sleep(stop_time):
    """ Curses sends a SIGWINCH to time.sleep and mp.Queue(timeout=) when the curses_window is resized, which terminates
        them prematurely. To prevent this we must build our own timer. (This will not fix mp.Queue(timeout=))
    """
    stop = timeit.default_timer() + stop_time
    while stop >= timeit.default_timer():
        try:
            _sleep(max(0, stop - timeit.default_timer()))
        except ValueError:
            pass

def run_linux(command, stdout=subprocess.PIPE):
    result, error = subprocess.Popen(
        command,
        stdout=stdout,
        stderr=subprocess.PIPE,
        shell=True,
        universal_newlines=True).communicate()
    return result, error

def terminate_processes(message=None):
    exception = str(traceback.format_exc())
    terminate_curses()
    time.sleep(.1)
    if "KeyboardInterrupt" not in exception and "None\n" not in exception:
        print(exception)
    if message:
        print(message)
    term_sig = 15
    try:
        os.killpg(os.getpgid(0), term_sig)
    except (TypeError, OSError):
        pass

def terminate_curses():
    curses.echo()
    curses.nocbreak()
    curses.curs_set(1)
    curses.endwin()


# ======================================================================================================================
#   Main
# ======================================================================================================================

class Main(object):
    event_queues = [None] * MAX_TABS
    system_queues = [None] * MAX_TABS
    frame_draw_current_queue = multiprocessing.Value("i", 0)
    frame_draw_state_queue = multiprocessing.Value("i", 0)
    process_frame_controllers = [None] * MAX_TABS
    process_event_controller = None
    stdscr = None

    @classmethod
    def start_curses(cls):
        cls.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        cls.stdscr.keypad(True)
        curses.start_color()
        cls.curses_color_setup()

    @staticmethod
    def curses_color_setup():
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_BLUE)
        curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(31, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(32, curses.COLOR_BLACK, curses.COLOR_CYAN)
        curses.init_pair(33, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(34, curses.COLOR_BLACK, curses.COLOR_RED)

    @classmethod
    def spawn_frame_controllers(cls):
        for tab_id in Settings.tab_ids:
            cls.spawn_frame_controller(tab_id, Settings._frame_controller_seeds[tab_id])

    @classmethod
    def spawn_frame_controller(cls, tab_id, frame_controller_seed):
        cls.event_queues[tab_id] = multiprocessing.Queue(0)
        cls.system_queues[tab_id] = multiprocessing.Queue(0)
        cls.process_frame_controllers[tab_id] = multiprocessing.Process(
            target=frame_controller_seed.frame_controller,
            args=(
                tab_id,
                cls.event_queues[tab_id],
                cls.system_queues[tab_id],
                cls.frame_draw_current_queue,
                cls.frame_draw_state_queue))

    @classmethod
    def start_frame_controllers(cls):
        for tab_id in Settings.tab_ids:
            cls.process_frame_controllers[tab_id].start()

    @classmethod
    def main_controller(cls):
        event_controller_seed = EventController()
        cls.process_event_controller = multiprocessing.Process(
            target=event_controller_seed.event_controller,
            args=(
                cls.stdscr,
                cls.event_queues,
                cls.system_queues
            ))
        cls.process_event_controller.start()
        cls.process_event_controller.join()

class MainSavedRun(Main):

    @classmethod
    def spawn_frame_controllers(cls):
        if Settings.run_compression == "gzip":
            with gzip.GzipFile(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(run_file)
        elif Settings.run_compression == "bz2":
            with bz2.BZ2File(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(run_file)
        else:
            with open(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(run_file)

    @classmethod
    def load_pickle(cls, run_file):
        try:
            # load Settings first
            try:
                # encoding=Latin is used by Python 3 to read Python 2 files
                pickle.load(run_file, fix_imports=True, encoding='latin1')
            except TypeError:
                # Python 2 does not have fix_imports
                pickle.load(run_file)

            Settings.load_saved_run = True
            Settings.start_tab_id = Settings.tab_ids[0]
            # we need to rebuild help tab, as we don't want to use the saved help
            Settings._setup_help()

            # load frames
            for tab_id in Settings.tab_ids:
                if tab_id == Settings.tab_id_help:
                    # we load in the help separately, as it is not from the saved group)
                    cls.spawn_frame_controller(Settings.tab_id_help,
                                               Settings._frame_controller_seeds[Settings.tab_id_help])
                else:
                    # if we load data into a FrameController cls instance, then spawn a new FC processes from that
                    # instance, the instance data will be copied into the new processes
                    try:
                        # encoding=Latin is used by Python 3 to read Python 2 files
                        frame_controller_seed = pickle.load(run_file, fix_imports=True, encoding='latin1')
                    except TypeError:
                        # Python 2 does not have fix_imports
                        frame_controller_seed = pickle.load(run_file)

                    Settings.saved_frame_count = max(len(frame_controller_seed.frame_state) - 1,
                                                     Settings.saved_frame_count)
                    cls.spawn_frame_controller(tab_id, frame_controller_seed)
                    del frame_controller_seed

        except EOFError:
            # TODO make a error message
            # not enough items to read in
            pass

if __name__ == "__main__":

    # make our own custom sleep
    time.sleep = new_sleep

    process_argparse()

    try:
        if Settings.load_saved_run:
            main = MainSavedRun()
        else:
            main = Main()
        main.start_curses()
        main.spawn_frame_controllers()
        main.start_frame_controllers()
        main.main_controller()
    except:
        terminate_processes()
