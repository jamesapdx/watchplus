#!/usr/bin/python
# pylint: disable=line-too-long, missing-docstring , attribute-defined-outside-init, too-many-lines, fixme
# pylint: disable=invalid-name, no-else-return, redifined-outer-name, too-many-statements, bare-except
from __future__ import print_function

# -*- encoding: utf8 -*-

import os
import sys
import subprocess
import multiprocessing
import threading
import time
import timeit
import datetime
import argparse
import traceback
import bisect
import string
import shlex
import fcntl
import bz2
from time import sleep as _sleep

try:
    # sys.intern() in python3, just intern() in python2
    from sys import intern
except ImportError:
    pass
try:
    # sys.exc_clear in python2, not python3. don't really need it in python3
    from sys import exc_clear  # pylint: disable= unused-import
except ImportError:
    throw_away = lambda *args, **kwargs: 1
    sys.exc_clear = throw_away
try:
    import curses
except ImportError:
    print("Unable to load python-curses. You may need to install the package on the OS (yum install python-curses).")
    sys.exit()
try:
    # python 2 import cpickle, python 3 already cpickle
    import cPickle as pickle
except ImportError:
    import pickle


# ======================================================================================================================
#   Arguments and flags
# ======================================================================================================================

MAX_COMMANDS = 20
MAX_LINE_LENGTH = 10000  # number of characters on a line, will truncate if needed
MAX_TABS = 99
HELP_TAB = 90

def process_argparse():
    # first split all command line args based on -- only
    cl_argv_split = split_command_line_argv()

    # get command line commands
    source = "command line"
    cl_system_args, cl_command_args = extract_system_command_args(cl_argv_split, source)

    if cl_system_args.open:
        Settings.load_saved_run = True
        Settings.load_run_file = cl_system_args.open.name
        return

    # process -f file args
    f_system_args = []
    f_command_args = []
    if cl_system_args.arg_file:
        f_argv_split = read_file_args(cl_system_args.arg_file)

        # read command args and more system args from file if exists
        source = cl_system_args.arg_file.name
        f_system_args, f_command_args = extract_system_command_args(f_argv_split, source)

    # command line system args take precedence over file system args
    system_args = merge_namespace(f_system_args, cl_system_args)

    # file commands take precedence over command line commands, too confusing otherwise
    command_args = f_command_args + cl_command_args

    commands_assigned, commands_unassigned = assign_commands_to_tabs(command_args)

    print_commands(commands_assigned, commands_unassigned)
    validate_args(system_args, commands_assigned)
    store_args_in_settings(system_args, commands_assigned, commands_unassigned)

def merge_namespace(first, precedence):
    if first and precedence:
        new = vars(first)
        new.update(vars(precedence))
        return argparse.Namespace(**new)
    return first if first else precedence

def split_command_line_argv():
    argv_split = [[]]
    for argv in sys.argv[1:]:
        # split into command groups based on --, it's the only way argparse can handle it
        if argv == "-h" or argv == "--help":
            print_help()
            sys.exit()
        elif argv == "--":
            argv_split.append([])
        elif argv.startswith("-") and argv in argv_split[-1]:
            message = "duplicate {}, perhaps missing '--' separator".format(argv)
            raise argparse.ArgumentError(None, message)
        else:
            argv_split[-1].append(argv)

    return argv_split

def extract_system_command_args(argv_split, source):
    """
    :return: system_args = argparse.Namespace
             command_args = [argparse.Namespace,...]
    """
    system_args = None
    command_args = []

    # strip out system options as an argparse.Namespace
    parser = init_system_parser()
    add_system_args(parser)
    namespace = None
    for count, argv in enumerate(argv_split):
        arg = parser.parse_known_args(args=argv, namespace=namespace)
        system_args = arg[0]
        # namspace is used to preserve "running total" of sys args
        namespace = system_args
        argv_split[count] = arg[1]

    # convert to argparse.Namespace objects
    for argv in argv_split:
        if argv:
            parser = init_command_parser()
            add_command_args(parser)
            command_args.append(parser.parse_args(args=argv))
            command_args[-1].source = source
            command_args[-1].original = argv

    return system_args, command_args

def read_file_args(arg_file_object):
    argv_split = []
    with arg_file_object as f:
        for line in f:
            argv_split.append(shlex.split(line, comments=True))
    argv_split = list(filter(len, argv_split))
    return argv_split

def assign_commands_to_tabs(command_args):
    """
    :return: [argparse.Namespace,...] note: len = 40, can contain None values throughout because of
            manual assignment flag
    """
    tab_text = {1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '0',
                11: 'shift-1', 12: 'shift-2', 13: 'shift-3', 14: 'shift-4', 15: 'shift-5', 16: 'shift-6',
                17: 'shift-7', 18: 'shift-8', 19: 'shift-9', 20: 'shift-0'}
    commands_assigned = [None] * MAX_COMMANDS
    commands_temp = []
    commands_unassigned = []

    # first assign to tab commands with -t option and put all remaining in commands_temp
    for command in command_args:
        tab = command.tab
        if tab and tab > 0 and tab <= MAX_COMMANDS:
            if not commands_assigned[tab - 1]:
                command.tab_label = tab_text[tab]
                commands_assigned[tab - 1] = command
                continue
        commands_temp.append(command)

    # add remaining to assigned and unassigned as argparse.Namespace
    for command in commands_temp:
        for count, tab in enumerate(commands_assigned):
            if not tab:
                command.tab_label = tab_text[count + 1]
                commands_assigned[count] = command
                break
        else:
            commands_unassigned.append(command)

    for count, command in enumerate(commands_assigned):
        if command:
            p = "tab {:8}: {} from {}"
            commands_assigned[count].print = p.format(tab_text[count + 1], command.original, command.source)
    for count, command in enumerate(commands_unassigned):
        p = "exceeded {} cmds, not using {} from {}"
        commands_unassigned[count].print = p.format(MAX_COMMANDS, command.original, command.source)

    return commands_assigned, commands_unassigned

def print_commands(commands_assigned, commands_unassigned):
    if False:
        for command in commands_assigned:
            if command:
                print(command.print)
        for command in commands_unassigned:
            print(command.print)

def validate_args(system_args, commands_assigned):
    if not [c for c in commands_assigned if c]:
        message = "No commands found."
        raise argparse.ArgumentError(None, message)

    if system_args.interval < .01:
        raise argparse.ArgumentError(None, "Interval cannot be less than .01.")

def store_args_in_settings(system_args, commands_assigned, commands_unassigned):
    Settings.interval = system_args.interval
    Settings.timeout = min(.1, Settings.interval * .4)
    Settings.precision = system_args.precision
    Settings.run_path = os.path.expanduser('~/')
    Settings.run_compression = True
    Settings.max_line_length = MAX_LINE_LENGTH

    for count, command in enumerate(commands_assigned):
        if command:
            Settings.commands[count] = vars(command)["\"cmd\""]
            Settings.commands_assigned.append(command.print)
            Settings._frame_controller_seeds[count] = FrameControllers()
            Settings.bottom_bar_tab_label[count] = command.tab_label
            Settings.bottom_bar_label[count] = "".join([x for x in Settings.commands[count] if x in Settings.printable])
            Settings.window_ids.append(count)
            Settings.streaming[count] = command.streaming
            Settings.glue_bottom[count] = command.glue_bottom
            Settings.no_change[count] = command.no_change
            Settings.no_line_wrap[count] = command.no_line_wrap
            Settings.green_text[count] = command.green_text
    Settings.start_window_id = Settings.window_ids[0]
    for command in enumerate(commands_unassigned):
        Settings.commands_unassigned.append(command.print)

    Settings._setup_help()

def print_help(stdout=True):
    parser = init_system_parser()
    add_system_args(parser)
    add_command_args(parser)
    if stdout:
        parser.print_help()
    else:
        return parser.format_help()

def init_system_parser():
    try:
        terminal_width = int(run_linux("tput cols")[0])
    except ValueError:
        terminal_width = 120
    format_func = lambda prog: argparse.RawTextHelpFormatter(prog, width=terminal_width - 2, max_help_position=32)
    usage = "%(prog)s [-o <f>] | [-f <f>] | [sys options] [cmd options] \"cmd\" [ -- [cmd options] \"cmd\" ]..."
    description = "%(prog)s - a better watch. Featuring pause, rewind and forward, scrolling up and down, line " \
    "wrapping, multiple tabs running indivudal commands simultaneously, and saving runs. Also supports " \
    "streaming commands such as ping and tcpdump."
    epilog = """
Keys controlling playback and viewing:
  Playback controls (all tabs at once):
     Space ............................... Play | Pause  (does not stop recording)
     r ................................... Start | Stop recording Frames
     A a s | d f F ....................... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     Left | Right Arrows (ctrl, shift) ... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     w | e ............................... First << >> Last  Frames
  Viewing controls:
     1-0, shift 1-0 ...................... Change tab
                                           1-0 = tab 1-10, shft-1-0 = tab 11-20
     k j ................................. Up | Down
     Up | Down Arrows .................... Up | Down
     Ctrl-u | Ctrl-d ..................... Half page up | down
     Ctrl-b | Ctrl-f ..................... Page up | down
     Page-Up | Page-Down ................. Page up | down
     g | G ............................... Top | Bottom
     x ................................... Toggle change history display on/off
     l ................................... Toggle line wrap
  Other controls:
     crtl-w .............................. Write frames and tabs to ~/[date_time].wp
                                           Stops recording during write. Load: -o <f>
     crtl-h .............................. View this help and tab assignments
     ctrl-c .............................. Quit"""

    return argparse.ArgumentParser(formatter_class=format_func,
                                   description=description,
                                   usage=usage,
                                   epilog=epilog,
                                   add_help=False)

def init_command_parser():
    return argparse.ArgumentParser()

def add_system_args(parser):
    group = parser.add_argument_group("Run file")
    group.add_argument("-o", "--open", dest="open", type=argparse.FileType('r'), metavar="<f>",
                       help="Load %(prog)s run file <f> that was saved from a past run.\n"
                            "Use ctrl-w after a run to save to a run file.")

    group = parser.add_argument_group("Setup File")
    group.add_argument("-f", "--file", dest="arg_file", type=argparse.FileType('r'), metavar="<f>",
                       help="Read [sys options] [cmd options] \"cmd\" from file <f>.\n"
                            "One command per line. Example:\n-n 1 -p\n\"dmesg\"\n-s \"ping -4 1.1.1.1\"")

    group = parser.add_argument_group("System options (applies to all tabs)")
    group.add_argument("-n", "--interval", dest="interval", type=float, metavar="<s>", default=1.0,
                       help="Interval in <seconds>, minimum .01, default = 1.0.")
    group.add_argument("-p", "--precise", dest="precision", action="store_true",
                       help="Attempt to maintain interval, drop frame if not completed in time.")
    group.add_argument("-h", "--help", dest="show_help", action="store_true",
                       help="Show this help.")

def add_command_args(parser):
    group = parser.add_argument_group("Tab/Command options")
    group.add_argument("--", dest="separator", action="store_true",
                       help="Separator for commands on command line. Not needed for the first one.\n"
                            "Example: %(prog)s -n 1 \"dmesg\" -- -s \"ping -4 1.1.1.1\" -- \"nstat\"")
    group.add_argument("-s", "--streaming", dest="streaming", action="store_true",
                       help="Use with continual streaming commands such as tcpdump and ping.")
    group.add_argument("-b", "--bottom", dest="glue_bottom", action="store_true",
                       help="Start this tab at the bottom of the output, similar to follow option.")
    group.add_argument("-x", "--change", dest="no_change", action="store_true",
                       help="Do not display change history. Can be toggled on/off with 'x'.")
    group.add_argument("-l", "--line_wrap", dest="no_line_wrap", action="store_true",
                       help="Disable line wrap. Can be toggled on/off with 'l'.")
    group.add_argument("-g", "--green", dest="green_text", action="store_true",
                       help="Use green text.")
    group.add_argument("-t", "--tab", dest="tab", type=int, metavar="<t>",
                       help="Assign this command to tab <t> if possible, 1-{}.\n".format(MAX_COMMANDS))
    group.add_argument("\"cmd\"", help="Command to be run, up to {} allowed, each in in a separate tab.\n"
                                       "Note: enclose in DOUBLE quotes with inside escaped quotes as needed.".
                       format(MAX_COMMANDS))

class Settings(object):
    # tab/command settings (mostly from argparse)
    printable = string.digits + string.punctuation + string.ascii_letters + " "
    commands = [None] * MAX_TABS
    _frame_controller_seeds = [None] * MAX_TABS
    commands_assigned = [None]
    commands_unassigned = []
    bottom_bar_tab_label =  [None] * MAX_TABS
    bottom_bar_label = [None] * MAX_TABS
    text = [None] * MAX_TABS
    streaming = [False] * MAX_TABS
    glue_bottom = [False] * MAX_TABS
    no_change = [False] * MAX_TABS
    no_line_wrap = [False] * MAX_TABS
    green_text = [False] * MAX_TABS
    random_text_colors = [False] * MAX_TABS

    # general and system settings
    window_ids = []
    interval = 1
    timeout = .4
    precision = False
    start_window_id = 0
    run_path = ""
    run_compression = True
    max_line_length = MAX_LINE_LENGTH
    load_saved_run = False
    load_run_file = ""

    @classmethod
    def _setup_help(cls):
        if not hasattr(cls, "window_id_help"):
            cls.window_id_help = HELP_TAB
            cls.window_ids.append(cls.window_id_help)
        cls.text[cls.window_id_help] = print_help(stdout=False)
        cls.commands[cls.window_id_help] = "Help Screen"
        cls.bottom_bar_tab_label[cls.window_id_help] = "ctrl-h"
        cls.bottom_bar_label[cls.window_id_help] = "Help Screen"
        cls._frame_controller_seeds[cls.window_id_help] = FrameControllersHelp()
        cls.no_line_wrap[cls.window_id_help] = False
        cls.no_change[cls.window_id_help] = True
        cls.glue_bottom[cls.window_id_help] = False

    @classmethod
    def __getstate__(cls):
        # this is needed to pickle class variables. Skip private variables and methods
        # any variable and methods that should not be including in saved runs should be private with _ in front
        return {var_name: cls.__dict__[var_name] for var_name in cls.__dict__ if not var_name.startswith("_")}

    @classmethod
    def __setstate__(cls, state):
        for var_name, value in state.items():
            setattr(cls, var_name, value)

class Debug():
    """ Place Debug.debug_to_file(message, message, etc.) anywhere message will be output to debug_file.
    decorate a method with @Debug.debug_timer the time will be recorded to debug_file.
    """
    debug_file = "debug"

    @classmethod
    def debug_to_file(cls, *message):
        # enhance: change this to logging
        with open(cls.debug_file, "a") as f:
            for item in message:
                f.write(str(item) + " ")
            f.write(" \n")

    @classmethod
    def debug_timer(cls, func):
        # decorate a method with @Debug.debug_timer
        def wrapper_timer(*args, **kwargs):
            start = timeit.default_timer()
            func(*args, **kwargs)
            stop = timeit.default_timer()
            cls.debug_to_file(func.__name__, " time to complete: ", stop - start)
            # print(func.__name__, " time to complete: ", stop - start)
            return func(*args, **kwargs)
        return wrapper_timer


# ======================================================================================================================
#   Frame Controller, drawing the output, moving around, switching tabs (windows)
# ======================================================================================================================

class FrameControllers(object):
    """This is the main controlling class.

       Frames are merely the collection of the stdout (or stderr) of the target command or script. If the target
       command or script is run every second for 10 seconds, 10 frames (outputs) will be generated and stored.
       Heatmaps are numerical representation for the change state of each character in a frame, it's the highlighting
       that occurs when a character changes from one frame to the next. See the FrameGenerators class for more details.

       This class is utilized inside a multiprocess subprocess, one subprocess for each target command or script.

       Class data can only be accessed from within the subprocess, multiprocess queues are utilized to share data between
       processes.
       """

    def __getstate__(self):
        includes = [
        "lines_chars",
        "lines_chars_pointers",
        "lines",
        "lines_states",
        "lines_pointers",
        "lines_lengths",
        "frame_length",
        "frame_state",
        "frame_date_time",
        "current",
        "streaming"]
        return {var_name: self.__dict__[var_name] for var_name in self.__dict__ if var_name in includes}

    def __setstate__(self, state):
        self.__dict__.update(state)

    def init_common(self):
        self.event = None
        self.max_line_length = Settings.max_line_length
        self.max_line_length_message = " ...MAX LINE LENGTH EXCEEDED ({})!!".format(self.max_line_length)
        self.max_line_length_total = len(self.max_line_length_message) + self.max_line_length

        # tab fields
        self.tab_active_tab = False
        self.draw_height_adder = 0
        self.draw_width_adder = 0
        self.terminal_draw_height = 0
        self.terminal_draw_width = 0
        self.window = None
        self.terminal_height = 0
        self.terminal_width = 0
        self.y_top_line = 0
        self.y_top_num_wrapped_lines = 0
        self.draw_move = 0
        # non-live playback is a always 1 second.
        self.playback_speed = 1
        self.next_playback = 0
        self.next_frame_type = "first"
        self.next_heatmap_type = "first"

    def init_frame(self):
        # frame fields
        self.lines_chars = []
        self.lines_chars_pointers = []
        self.lines = []
        self.lines_states = []
        self.lines_pointers = []
        self.lines_lengths = []
        self.frame_length = []
        self.frame_state = []
        self.frame_date_time = []
        self.current = - 1

        self.draw_current = -2
        self.draw_state = "stop"
        self.recording_state = "record"

    def init_start_tab(self):
        if self.window_id == Settings.start_window_id:
            self.tab_active_tab = True
            self.draw_state = "live"

    def init_curses_window(self):
        # create a new curses window

        # standard settings
        self.window = curses.newwin(0, 0)
        self.window.nodelay(1)
        self.window.keypad(True)
        # these two might help with screen flicker
        self.window.idcok(False)
        self.window.idlok(False)
        self.window.erase()
        # curses needs an initial write or it draws the first frame with artifacts
        for x in range(200):
            self.window.addstr(" ")
        self.window.redrawwin()
        self.window.refresh()

    def init_event(self):
        self.event_choices = {
            # frames
            "start new frame": self.new_frame_request,  # comes from event controller self.event_queue
            "new frame": self.new_frame_received,  # comes from frame generator self.event_queue
            # windows
            "tab change": self.change_tabs,
            "refresh": self.draw_live_frame,
            "back": self.frames_back,
            "forward": self.frames_forward,
            "window move": self.move_window_up_down,
            # toggle items
            "toggle draw state": self.toggle_draw_state,
            "toggle recording": self.toggle_recording,
            "toggle line wrap": self.toggle_line_warp,
            "toggle change": self.toggle_change,
            "clear history": self.clear_history,
            # save
            "save": self.write_to_file}

    def init_generator_childprocess(self):
        self.process_generator = None
        self.generator_seed = FrameGenerators()
        self.generator_frame_queue = multiprocessing.Queue(0)
        self.generator_event_queue = multiprocessing.Queue(0)
        self.process_generator = multiprocessing.Process(
            target=self.generator_seed.generator_controller,
            args=(
                self.command,
                self.generator_frame_queue,
                self.generator_event_queue,
                self.event_queue,
                self.streaming
            ))
        self.process_generator.start()

    def frame_controller(self, window_id, event_queue, system_queue, frame_draw_current_queue, frame_draw_state_queue):
        """ This is the main method that controls storing and drawing frames. First, it spawns a never
            ending generator subprocesses that builds the frames.  The generator sends the data back
            through queues, which is then stored and drawn.
                generator           --> | event queue  | (let's us know a new frame is available)
                generator.new_frame --> | frame_queue  | --> self.frame  (the frame itself
            """
        try:
            # init settings
            self.command = Settings.commands[window_id]
            self.window_id = window_id
            self.event_queue = event_queue
            self.system_queue = system_queue
            self.frame_draw_current_queue = frame_draw_current_queue
            self.frame_draw_state_queue = frame_draw_state_queue
            self.bottom_bar_tab_label = Settings.bottom_bar_tab_label[window_id]
            self.bottom_bar_label = Settings.bottom_bar_label[window_id]
            self.interval = Settings.interval
            self.streaming = Settings.streaming[window_id]
            self.glued_to_bottom = True if self.streaming or Settings.glue_bottom[window_id] else False
            self.no_change = Settings.no_change[window_id]
            self.no_line_wrap = Settings.no_line_wrap[window_id]
            self.green_text = Settings.green_text[window_id]

            # init
            self.init_common()
            self.init_frame()
            self.init_start_tab()
            self.init_event()
            self.init_generator_childprocess()

            # get windows ready
            self.init_curses_window()
            self.get_terminal_size()

            # tell event controller we are ready to go
            self.system_queue.put(1)

            # Start looping here
            self.main_loop()

        except:
            terminate_processes()

    def main_loop(self):
        timeout = min(.02, self.interval * .2)
        while True:
            # self.event expects a list, sent by another process
            try:
                # self.event is a list, [0] is the command, [1+] is options, see self.event_choices above
                self.event = self.event_queue.get(block=True, timeout=timeout)

            except multiprocessing.queues.Empty:
                self.playback()
            else:
                # run the appropriate self.event_choices function
                # an event can be from the event controller (new frame or keystrokes) or from child generator (new frame)
                self.event_choices.get(self.event[0], "")()

    # PROCESS FRAMES ######################

    def new_frame_request(self):
        # the event controller process tells all tabs it's time for a new event
        self.new_stop_time = self.event[1]
        self.new_start_time = self.event[2]
        self.precision = self.event[3]

        if len(self.frame_state) == 0:
            self.next_frame_type = "first"
            self.precision = False

        # request new frame from the child generator
        try:
            self.generator_event_queue.put([self.next_frame_type,
                                            self.new_stop_time,
                                            self.precision,
                                            self.terminal_draw_width], timeout=Settings.timeout)
            self.next_frame_type = "normal"
        except multiprocessing.queues.Full:
            pass

    def new_frame_received(self):
        self.new_frame_store()

        if self.draw_state == "live":
            self.draw_current = self.current

        self.draw_live_frame()
        # tell the event controller we are done adding a new frame
        self.system_queue.put(1)

    def new_frame_store(self):
        self.frame_state.append(self.event[1])
        self.frame_length.append(self.event[2])
        self.frame_date_time.append(self.new_start_time)

        self.current = len(self.frame_state) - 1

        new = self.current
        previous = max(0, new - 1)

        try:
            frame_changes, frame_line_numbers = self.generator_frame_queue.get(block=True, timeout=Settings.timeout)
        except multiprocessing.queues.Empty:
            # unable to get anything from the queue, just consider this an error and drop the frame
            self.frame_state[new] = "dropped"
            self.frame_length[new] = 0
        else:
            if self.frame_state[new] == "dropped":
                self.frame_length[new] = 0
            elif len(frame_changes) == 0:
                # TODO fix len frame_changes == 0
                pass
            elif self.frame_state[new] == "first":
                # first frame ever, so easy store
                for line in frame_changes:
                    line_length = min(len(line), self.max_line_length_total)

                    if line_length > self.max_line_length:
                        self.lines.append([intern(line[:self.max_line_length]) + self.max_line_length_message])
                    else:
                        self.lines.append([intern(line)])

                    self.lines_pointers.append([0])
                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    # we store all chars changes and pointers for the yellow change history. Otherwise
                    # we would have to search all previous changed lines everytime we display a frame
                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])
            else:
                for counter, line_number in enumerate(frame_line_numbers):
                    line_length = min(len(frame_changes[counter]), self.max_line_length_total)

                    # truncate the line if too long
                    if line_length > self.max_line_length:
                        line = frame_changes[counter][:self.max_line_length] + self.max_line_length_message
                    else:
                        line = frame_changes[counter]

                    if line_number >= len(self.lines):
                        # must be a new line, longer than the existing output

                        self.lines.append([intern(line)])
                        # use a pointer, don't store the line over and over, future frames just access the pointer
                        self.lines_pointers.append([new])
                        # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                        self.lines_states.append([2])
                        # store the individual line length for use later
                        self.lines_lengths.append([line_length])

                        # we store all chars changes and pointers for the yellow change history. Otherwise
                        # we would have to search all previous changed lines everytime we display a frame
                        self.lines_chars.append([[char] for char in line])
                        self.lines_chars_pointers.append([[new] for x in range(line_length)])
                    else:
                        # this a change on an existing line in the output
                        self.lines[line_number].append(intern(line))
                        self.lines_pointers[line_number].append(new)
                        self.lines_lengths[line_number].append(line_length)
                        # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                        self.lines_states[line_number].append(1)

                        # we store all chars changes and pointers for the yellow change history. Otherwise
                        # we would have to search all previous changed lines everytime we display a frame
                        for column, char in enumerate(line):
                            if column >= len(self.lines_chars[line_number]):
                                self.lines_chars[line_number].append([char])
                                self.lines_chars_pointers[line_number].append([new])
                            elif column >= self.lines_lengths[line_number][-2]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            elif line_number >= self.frame_length[previous]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            else:
                                if self.lines_chars_pointers[line_number][column][-1] == 0:
                                    last_char = self.lines[line_number][0][column]
                                else:
                                    last_char = self.lines_chars[line_number][column][-1]
                                if last_char != char:
                                    self.lines_chars[line_number][column].append(char)
                                    self.lines_chars_pointers[line_number][column].append(new)

    # TOGGLE ITEMS ######################

    def toggle_recording(self):
        self.recording_state = self.event[1]
        if self.recording_state == "record":
            if self.current == self.draw_current:
                self.draw_state = "live"
            else:
                self.draw_state = "pause"
        else:
            self.draw_state = "pause"
            if self.streaming:
                try:
                    self.generator_event_queue.put(["pause", None, None, self.terminal_draw_width],
                                                   timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        self.draw_live_frame()

    def toggle_change(self):
        if self.no_change == False:
            self.no_change = True
        else:
            self.no_change = False
        self.draw_live_frame()

    def toggle_line_warp(self):
        if self.no_line_wrap:
            self.no_line_wrap = False
        else:
            self.no_line_wrap = True
        self.draw_live_frame()

    def toggle_draw_state(self):
        if self.draw_state == "play" or self.draw_state == "live":
            self.draw_state = "pause"
        else:
            if self.draw_current == self.current:
                self.draw_state = "live"
            else:
                self.draw_state = "play"
                self.next_playback = timeit.default_timer() + self.playback_speed
        self.draw_live_frame()

    def clear_history(self):
        # TODO clear history
        self.draw_live_frame()

    # DRAW FRAMES ######################

    def change_tabs(self):
        if self.event[2] == "new":
            # moving to this tab
            self.tab_active_tab = True

            # 0 = latest, otherwise use draw_frame
            self.draw_current = self.frame_draw_current_queue.value
            self.draw_state = {0: "pause", 1: "play", 2: "live"}[self.frame_draw_state_queue.value]
            if self.draw_state == "play":
                self.next_playback = timeit.default_timer() + self.playback_speed
            elif self.draw_state == "live":
                self.draw_current = self.current

            self.draw_live_frame()
        else:
            # moving from this tab, pass items in the queue to the new tab
            self.tab_active_tab = False
            self.frame_draw_current_queue.value = self.draw_current
            self.frame_draw_state_queue.value = {"pause": 0, "play": 1, "live": 2}[self.draw_state]
            # self.window.erase()
            # self.window.redrawwin()
            self.window.refresh()

    def playback(self):
        if self.draw_state == "play" and timeit.default_timer() > self.next_playback:
            self.draw_current +=1
            if self.draw_current == self.current:
                self.draw_state = "live"
            self.draw_live_frame()
            self.next_playback = timeit.default_timer() + self.playback_speed

    def get_terminal_size(self):
        # need to refresh before getting size
        self.window.refresh()
        self.terminal_height, self.terminal_width = self.window.getmaxyx()

        self.terminal_draw_height = self.terminal_height - self.draw_height_adder
        self.terminal_draw_width = self.terminal_width - self.draw_width_adder

    def frames_back(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = 0
        else:
            self.draw_current = max(0, self.draw_current - amount)
        self.draw_state = "pause"
        self.draw_live_frame()

    def frames_forward(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = self.current
        else:
            self.draw_current = min(self.current, self.draw_current + amount)
        if self.draw_current == self.current:
            self.draw_state = "live"
        else:
            self.draw_state = "pause"
        self.draw_live_frame()

    def move_window_up_down(self):
        self.get_terminal_size()
        direction = self.event[1]
        amount = self.event[2]

        if direction == "down":
            if amount == "one":
                self.draw_move = 1
            elif amount == "page":
                self.draw_move = self.terminal_draw_height
            elif amount == "half":
                self.draw_move = int(self.terminal_draw_height / 2)
            elif amount == "bottom":
                self.glued_to_bottom = True

        if direction == "up":
            self.glued_to_bottom = False
            if amount == "one":
                self.draw_move = -1
            elif amount == "half":
                self.draw_move = -int(self.terminal_draw_height / 2)
            elif amount == "page":
                self.draw_move = -self.terminal_draw_height
            elif amount == "top":
                self.y_top_line = 0
                self.y_top_num_wrapped_lines = 0

        self.draw_live_frame()

    def line_wrap_off(self):
        """
        handle window moving here, using self.draw_move = +- lines
        """
        self.y_top_num_wrapped_lines = 0
        if self.frame_length[self.draw_current] <= self.terminal_draw_height:
            pass
        elif self.glued_to_bottom:
            self.y_top_line = self.frame_length[self.draw_current] - self.terminal_draw_height
        elif self.draw_move < 0:
            self.y_top_line += self.draw_move
            self.y_top_line = max(0, self.y_top_line)
        elif self.draw_move > 0:
            self.y_top_line += self.draw_move
            self.y_top_line = min(self.frame_length[self.draw_current] - self.terminal_draw_height, self.y_top_line)

        self.draw_move = 0

    def line_wrap(self):
        """
        Line wrap the frame to display, just the lines in the display range.
        Line wrapping is very complicated, must take into account glue_bottom, scrolling,
        terminal resizes, and more.  We could just let curses handle it, but it would only scroll
        an entire line at a time and not handle glue_bottom.

        Handle window moving here, using self.draw_move = +- lines
        """
        draw_current = self.draw_current
        if self.current == self.draw_current:
            live = True
        else:
            live = False
        bottom = None

        wrapped_lines = []

        if self.glued_to_bottom:
            counter = 0
            start = max(0, self.frame_length[draw_current] - (2 * self.terminal_draw_height))
            start = self.frame_length[draw_current] - 1
            for line_number in range(start, -1, -1):
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    # TODO: grep / filter out items here
                    # if x not in self.lines[line_number]:
                    #    continue

                sub_lines = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                for sub_line in range(sub_lines + 1):
                    wrapped_lines.append([line_number, sub_line])
                    counter += 1

                if counter > self.terminal_draw_height + 1:
                    break

            wrapped_lines.reverse()

            if len(wrapped_lines) > self.terminal_draw_height:
                wrapped_top = len(wrapped_lines) - self.terminal_draw_height
            else:
                wrapped_top = 0
            self.y_top_line = wrapped_lines[wrapped_top][0]
            self.y_top_num_wrapped_lines = wrapped_lines[wrapped_top][1]
            wrapped_lines.reverse()
        else:
            if self.y_top_line < 0:
                self.y_top_line = 0
                self.y_top_num_wrapped_lines = 0
            elif self.y_top_line >= self.frame_length[draw_current]:
                self.y_top_line = self.frame_length[draw_current] - 1
                self.y_top_num_wrapped_lines = 0

            if self.y_top_num_wrapped_lines > 0:
                # the line may have shrunk on this frame and self.y_top_num_wrapped_liness may be to big, correct if needed
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[self.y_top_line], draw_current) - 1

                sub_lines = (self.lines_lengths[self.y_top_line][position] // self.terminal_draw_width)
                if self.y_top_num_wrapped_lines > sub_lines:
                    self.y_top_num_wrapped_lines = sub_lines

            if self.draw_move != 0:
                start = max(0, self.y_top_line - self.terminal_draw_height)
                end = min(self.frame_length[draw_current], self.y_top_line + (self.terminal_draw_height * 2))
                for line_number in range(start, end):
                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    sub_lines = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                    for sub_line in range(sub_lines + 1):
                        wrapped_lines.append([line_number, sub_line])

                    if line_number == self.frame_length[draw_current] - 1:
                        bottom = len(wrapped_lines) - 1

                wrapped_top = wrapped_lines.index([self.y_top_line, self.y_top_num_wrapped_lines])

                if self.draw_move < 0:
                    wrapped_top = max(0, wrapped_top + self.draw_move)
                else:
                    if len(wrapped_lines) > self.terminal_draw_height:
                        wrapped_top = min(len(wrapped_lines) - 1, wrapped_top + self.draw_move)
                        wrapped_bottom = min(len(wrapped_lines) - 1,
                                                  wrapped_top + self.terminal_draw_height - 1)
                        wrapped_top = wrapped_bottom - self.terminal_draw_height + 1

                        if wrapped_bottom == bottom:
                            self.glued_to_bottom = True
                    else:
                        wrapped_top = 0
                        self.glued_to_bottom = True

                self.y_top_line = wrapped_lines[wrapped_top][0]
                self.y_top_num_wrapped_lines = wrapped_lines[wrapped_top][1]
        self.draw_move = 0

    def draw_live_frame(self):
        if not self.tab_active_tab:
            return

        # use this for status bar
        self.draw_height_adder = 3
        # use this for line numbers (future)
        self.draw_width_adder = 0
        self.get_terminal_size()

        draw_current = self.draw_current

        # # using .clear() cause screen flicker.  Use erase() with redrawwin() and refresh()
        self.window.erase()

        if self.current < 0 or len(self.frame_state) == 0:
            status_bar, color_pair = self.status_bar_build()
        elif self.frame_state[draw_current] == "dropped":
            if self.precision is True:
                self.window.addstr("Command could not complete in time, frame dropped.")
            else:
                self.window.addstr("Error processing frame, frame dropped.")
            status_bar, color_pair = self.status_bar_build()
        elif self.frame_length[draw_current] == 0:
            status_bar, color_pair = self.status_bar_build()
        else:

            if self.no_line_wrap:
                self.line_wrap_off()
            else:
                self.line_wrap()

            draw_start = self.y_top_line
            draw_end = min(self.frame_length[draw_current], self.y_top_line + self.terminal_draw_height)
            live = True if draw_current == self.current else False

            try:
                for line_number in range(draw_start, draw_end):
                    # we don't stare the same line over an over, we just store it once and retrieve the pointer
                    # to that line.  we need bisect to find last closet pointer to the frame
                    # we are drawing (draw_current). if we are live than we can just grab the last pointer at [-1]
                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1
                    pointer = self.lines_pointers[line_number][position]

                    line_start = 0
                    if self.no_line_wrap:
                        # cut the line short to term width
                        line = self.lines[line_number][position][:self.terminal_draw_width - 1]
                    else:
                        # long line, let curses wrap it for us
                        line = self.lines[line_number][position]
                        if line_number == self.y_top_line:
                            # top line, calculate this because of chopped wrap
                            line_start = self.y_top_num_wrapped_lines * self.terminal_draw_width
                    line_length = len(line)
                    line_state = self.lines_states[line_number][position]

                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    color_text = 4 if self.green_text else 0
                    if line_state == 0 or self.no_change:
                        # no change on "pointed to" line, or display changes turned off
                        self.window.addstr(line[line_start:], curses.color_pair(color_text))
                    elif line_state == 2:
                        # change on new a new line (longer than previous output)
                        if pointer == draw_current:
                            # change on current frame, so use red
                            color = 2
                        else:
                            # change on older frame,so it is just a history, use yellow
                            color = 1
                        color_pair = curses.color_pair(color)
                        self.window.addstr(line[line_start:], color_pair)
                    else:
                        # this line self line_state == 1, change on an existing "pointed to" line
                        for column in range(line_start, line_length):
                            try:
                                char = line[column]
                            except IndexError:
                                char = "?"

                            position = -1
                            if not live:
                                position = bisect.bisect(self.lines_chars_pointers[line_number][column], draw_current) - 1
                            pointer = self.lines_chars_pointers[line_number][column][position]

                            try:
                                color = color_text
                                if pointer == 0:
                                    # the first frame, so no change
                                    pass
                                elif pointer == draw_current:
                                    # the new char is on this frame, so change color is red
                                    color = 2
                                else:
                                    # the new char is an old frame, so yellow history
                                    color = 1
                            except (IndexError, ValueError):
                                pass
                            color_pair = curses.color_pair(color)

                            self.window.addstr(char, color_pair)

                    self.window.addstr("\n")

            except curses.error:
                pass

            status_bar, color_pair = self.status_bar_build(draw_start, draw_end, self.frame_length[draw_current])

        # draw status bar to curses
        line_number = self.terminal_height - 1
        for column in range(self.terminal_width - 1):
            # need the terminal_width -1 because of a curses bug, it sticks a \n on the end of the last line
            try:
                char = str(status_bar[column])
            except IndexError:
                char = " "
            self.window.addstr(line_number, column, char, color_pair)
        self.window.addstr(line_number, column, " ", color_pair)
        self.window.insstr(line_number, column, " ", color_pair)

        self.window.redrawwin()
        self.window.refresh()

    def status_bar_build(self, draw_start=-1, draw_end=0, frame_height=0):
        try:
            date_time = self.frame_date_time[self.draw_current].strftime("%H:%M:%S.%f")
        except (AttributeError, IndexError):
            date_time = "--:--:--.---"

        # TODO stuck tab

        mode_text = {
            "waiting"      : ["Waiting", curses.color_pair(31)],
            "paused stop"  : ["|| PAUSED  ", curses.color_pair(34)],
            "paused"       : ["|| PAUSED  ", curses.color_pair(33)],
            "playback"     : [">> PLAYBACK", curses.color_pair(32)],
            "live stop"    : ["<> LIVE    ", curses.color_pair(34)],
            "live play"    : ["<> LIVE    ", curses.color_pair(31)],
            "stopped"      : [" (STOPPED) ", ""],
            "stuck"        : ["TAB X STUCK", curses.color_pair(34)],
            "other"        : ["", ""],
        }

        if self.current < 0:
            mode = "waiting"
        elif self.draw_state == "pause" and self.recording_state == "stop":
            mode = "paused stop"
        elif self.draw_state == "pause":
            mode = "paused"
        elif self.draw_state == "play":
            mode = "playback"
        elif self.draw_state == "play" and self.recording_state == "stop":
            mode = "live stop"
        elif self.draw_state == "live":
            mode = "live play"
        if self.recording_state == "stop":
            recording_mode = "stopped"
        else:
            recording_mode = "other"

        p = " {:>2} | {:.12} | {} {}/{} ( {}-{}/{} Lines ) | CH:{:3} LW:{:3} n:{:3} p:{} | TAB {}: {}"
        status_bar = p.format(
            date_time,
            mode_text[mode][0],
            mode_text[recording_mode][0],
            max(0, self.draw_current + 1),
            max(0, self.current + 1),
            max(0, draw_start + 1),
            max(0, min(draw_end, frame_height)),
            frame_height,
            "OFF" if self.no_change else "ON",
            "OFF" if self.no_line_wrap else "ON",
            self.interval,
            "ON" if self.precision else "OFF",
            self.bottom_bar_tab_label,
            self.bottom_bar_label)

        return status_bar, mode_text[mode][1]

    def write_to_file(self):
        run_file = self.event[1]
        if not self.window_id == Settings.window_id_help:
            try:
                if Settings.run_compression:
                    with bz2.BZ2File(run_file, 'ab') as f:
                        pickle.dump(self, f, protocol=2)
                else:
                    with open(run_file, 'ab') as f:
                        pickle.dump(self, f, protocol=2)
            except FileNotFoundError:
                # TODO add failed message, remove started file
                pass
                # except:
                # TODO add failed message, remove started file
                pass


class FrameControllersStatic(FrameControllers):
    """
    Run or display once and not again. use self.get_output() to control first frame output
    """

    def init_generator_childprocess(self):
        pass

    def new_frame_request(self):
        self.new_frame_store()

        self.system_queue.put(1)

        if self.draw_state == "live":
            self.draw_current = self.current

        self.draw_live_frame()

    def new_frame_received(self):
        pass

    def new_frame_store(self):
        self.frame_state.append("unchanged")
        self.frame_date_time.append(self.event[2])

        self.current = len(self.frame_state) - 1

        if self.current == 0:

            frame = self.get_output()

            for line in frame:
                if line is not None:
                    line_length = len(line)

                    self.lines.append([intern(line)])
                    self.lines_pointers.append([0])
                    # line_state: 0 no change, 1 line change on existing line, 2 change on new line
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])

            self.frame_state[self.current] = ("first")
            self.frame_length.append(len(self.lines))
        else:
            # expects the length to be the same even if there are no changes
            self.frame_length.append(self.frame_length[0])

    def get_output(self):
        # return any list of strings, this will be the first frame
        frame = []
        return frame

    def toggle_change(self):
        pass

    def clear_history(self):
        pass


class FrameControllersHelp(FrameControllersStatic):

    def get_output(self):
        help = Settings.text[Settings.window_id_help].splitlines()
        help += ["", "Tabs and Commands:"]
        help += ["      {}".format(x) for x in Settings.commands_assigned if x is not None]
        commands_unassigned = [x for x in Settings.commands_unassigned if x]
        if commands_unassigned:
            help += ["", "Unassigned Commands:"]
            help += ["      {}".format(x) for x in commands_unassigned if x]
        help = ["  {}".format(x) for x in help if x is not None]
        return help


class FrameControllersNoChange(FrameControllers):
    """TODO future home of not recording changes for performance"""
    pass


class FrameControllersSavedRun(FrameControllers):
    """TODO future home of saved runs"""

    def init_frame(self):
        self.draw_current = len(self.frame_state) - 1
        self.current = self.draw_current
        self.frame_draw_current_queue.value = self.draw_current
        self.draw_state = "pause"
        self.frame_draw_state_queue.value = 1 if self.draw_state == "play" else 0
        self.recording_state = "stop"

    def init_generator_childprocess(self):
        pass


class FrameControllersSavedRunNoChane(FrameControllersSavedRun, FrameControllersNoChange):
    """TODO future home of saved runs and no changes"""
    pass

# ======================================================================================================================
#   Frame Generator, running, reading, storing a command
# ======================================================================================================================

class FrameGenerators(object):

    def generator_controller(self, command, frame_queue, generator_event_queue, event_queue, streaming):
        try:
            self.frame = [[], []]
            self.frame_line_numbers = []
            self.frame_state = None
            self.frame_changes = []
            self.frame_length = [0, 0]
            self.frame_stream_length = 0
            self.terminal_draw_width = 0

            self.command = command
            self.frame_queue = frame_queue
            self.generator_event_queue = generator_event_queue
            self.event_queue = event_queue
            self.command_gid = None
            self.proc = None
            self.generator_event = None

            self.streaming = streaming
            self.precision = False
            self.current = 0
            self.last = 1
            self.frame_type = "first"
            self.stop_time = 0
            self.recording_state = "record"

            while True:

                # frame_controller sends us the parameters for this new frame
                self.generator_event = self.generator_event_queue.get(block=True)
                # self.frame_type = normal, full, first, stop, start
                self.frame_type = self.generator_event[0]
                self.stop_time = self.generator_event[1]
                self.precision = self.generator_event[2]
                self.terminal_draw_width = self.generator_event[3]

                if self.frame_type == "pause":
                    self.recording_state = "pause"
                    if self.streaming:
                        self.pause_gid(self.command_gid)
                        continue
                if self.streaming:
                    if self.recording_state == "pause":
                        self.continue_gid(self.command_gid)
                        self.recording_state = "record"
                    if self.frame_type == "first":
                        self.frame_generator_streaming_first()
                    self.frame_generator_streaming()
                else:
                    if self.recording_state == "pause":
                        self.recording_state = "record"
                    self.frame_generator()
                    self.frame_pre_change()
                    if self.precision is True and self.stop_time < timeit.default_timer():
                        self.dropped()

                self.put_queues()

        except:
            # continue any paused processes before quiting
            self.continue_gid(self.command_gid)
            self.terminate_gid(self.command_gid)
            terminate_processes()

    def dropped(self):
        self.command_gid = 0
        self.frame_state = "dropped"
        self.frame_length[self.current] = 0
        self.frame_changes = []

    def pause_gid(self, gid):
        term_sig = 19
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass

    def continue_gid(self, gid):
        term_sig = 18
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass

    def terminate_gid(self, gid):
        term_sig = 15
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass
        self.frame_state = "dropped"

    def run_command(self):
        env = dict(os.environ, COLUMNS=str(self.terminal_draw_width))

        proc = subprocess.Popen(
            self.command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            env=env,
            universal_newlines=True,
            preexec_fn=os.setsid
        )
        self.command_gid = os.getpgid(proc.pid)

        return proc

    # Streaming Generator starts here ####################

    def frame_generator_streaming_first(self):
        self.proc = self.run_command()
        fl_out = fcntl.fcntl(self.proc.stdout, fcntl.F_GETFL)
        fl_err = fcntl.fcntl(self.proc.stderr, fcntl.F_GETFL)
        fcntl.fcntl(self.proc.stdout, fcntl.F_SETFL, fl_out | os.O_NONBLOCK)
        fcntl.fcntl(self.proc.stderr, fcntl.F_SETFL, fl_err | os.O_NONBLOCK)

    def frame_generator_streaming(self):
        safe_margin = .0001
        end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)
        time.sleep(end_timer)

        try:
            result = self.proc.stdout.read()
        except TypeError:
            result = ""
        try:
            error = self.proc.stderr.read()
        except (TypeError, IOError):
            error = ""

        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()


        if self.frame_type == "first":
            self.frame_state = "first"
            self.frame_line_numbers = []
        elif not self.frame[self.current]:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []
        else:
            self.frame_state = "changed"
            self.frame_changes = self.frame[self.current]
            self.frame_line_numbers = list(
                range(self.frame_stream_length, self.frame_stream_length + len(self.frame[self.current])))

        self.frame_stream_length += len(self.frame[self.current])
        self.frame_length[self.current] = self.frame_stream_length

    # Non Streaming Generator starts here ####################

    def frame_generator(self):
        """ a frame is composed of a line by line list of the output from
            the assigned command for this window """

        self.proc = self.run_command()

        safe_margin = .0001
        if self.precision is True:
            end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)

            if end_timer > 0:
                timer = threading.Timer(end_timer, self.terminate_gid, args=(self.command_gid,))
                timer.start()

                result, error = self.proc.communicate()
                timer.cancel()
            else:
                # already missed our window before we even ran the command
                self.frame_state = "dropped"

            if self.frame_state == "dropped":
                self.dropped()
                return
        else:
            result, error = self.proc.communicate()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

        # break result into a line by line list, for python 2/3
        # TODO fix: imporve stderr
        # don't keep ends because in python 3 it could different ends, and we only want /n
        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = ""
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

    def frame_pre_change(self):
        self.frame_length[self.current] = len(self.frame[self.current])

        if self.frame_type == "first":
            self.frame_line_numbers = []
            self.frame_state = "first"
        elif self.frame_length[self.current] != self.frame_length[self.last]:
            self.frame_change()
        elif self.frame[self.current] != self.frame[self.last]:
            self.frame_change()
        else:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()

    def frame_change(self):
        self.frame_state = "changed"
        self.frame_changes = []
        self.frame_line_numbers = []
        for line_number, line in enumerate(self.frame[self.current]):
            try:
                if line != self.frame[self.last][line_number]:
                    self.frame_changes.append(line)
                    self.frame_line_numbers.append(line_number)
            except IndexError:
                self.frame_changes.append(line)
                self.frame_line_numbers.append(line_number)

    # Put queues #########################

    def put_queues(self):
        try:
            if self.frame_state == "first":
                self.frame_queue.put(
                    (self.frame[self.current], self.frame_line_numbers),
                    timeout=Settings.timeout)
            else:
                self.frame_queue.put(
                    (self.frame_changes, self.frame_line_numbers),
                    timeout=Settings.timeout)
        except multiprocessing.queues.Full:
            # missed the timout, that's ok, if nothing in the queue the receiver will just call it dropped
            pass

        self.event_queue.put([
            "new frame",
            self.frame_state,
            self.frame_length[self.current]])

        if self.frame_state != "dropped":
            if self.current == 0:
                self.current = 1
                self.last = 0
            else:
                self.current = 0
                self.last = 1


# ======================================================================================================================
#   Event Controller, key presses
# ======================================================================================================================

class EventController(object):

    def __init__(self):
        self.key_mapping()

    def event_controller(self, window, event_queues, system_queues):
        try:
            self.window = window
            self.draw_window_id = Settings.start_window_id
            self.event_queues = event_queues
            self.system_queues = system_queues
            self.draw_window_ids = Settings.window_ids
            self.start_time = timeit.default_timer()
            self.precision = Settings.precision
            self.new_stop_time = 0
            self.new_start_date_time = 0
            self.done_count = 0
            self.help = False
            self.last_tab = self.draw_window_id
            self.resize_request = 0
            self.recording_state = "stop" if Settings.load_saved_run else "record"

            # start here
            while True:
                # if step is too low performance will suffer
                step = min(.02, Settings.interval * .2)
                time.sleep(step)

                # we will give the tabs a stop time, tell them to start, wait to hear they all done, repeat
                # if precision = true they should finish on time
                if timeit.default_timer() > self.new_stop_time and self.recording_state == "record":
                    if self.done_count >= len(self.draw_window_ids):
                        self.done_count = 0
                        self.new_stop_time = Settings.interval + timeit.default_timer()
                        self.new_start_date_time = datetime.datetime.now()

                        for window_id in self.draw_window_ids:
                            event_queues[window_id].put(["start new frame",
                                                         self.new_stop_time,
                                                         self.new_start_date_time,
                                                         self.precision])
                    else:
                        for draw_window_id in self.draw_window_ids:
                            # collect "frame done" from the frame controllers
                            try:
                                x = int(self.system_queues[draw_window_id].get(block=False))
                                self.done_count += 1 if x == 1 else 0
                            except multiprocessing.queues.Empty:
                                pass

                # when a window is resized, a lot of events are fired once. We will delay a bit.
                if self.resize_request and timeit.default_timer() > self.resize_request:
                    try:
                        self.get_terminal_size()
                        self.event_queues[self.draw_window_id].put(["refresh"], block=False)
                        self.resize_request = 0
                    except multiprocessing.queues.Full:
                        pass

                # look for a keyboard input now
                self.keyboard_input()

        except:
            terminate_processes()

    def key_mapping(self):
        self.key_map = {
            ord(" ")          : ["one", "toggle draw state"],
            ord("l")          : ["one", "toggle line wrap"],

            # ord("-")          : ["one", "playback speed", "slower"],
            # ord("_")          : ["one", "playback speed", "slower"],
            # ord("+")          : ["one", "playback speed", "faster"],
            # ord("=")          : ["one", "playback speed", "faster"],

            curses.KEY_LEFT   : ["one", "back", 1],  # left-arrow
            ord("s")          : ["one", "back", 1],
            393               : ["one", "back", 10],  # shf-left-arror
            ord("a")          : ["one", "back", 10],
            552               : ["one", "back", 100],  # alt-shf-left-arrow
            546               : ["one", "back", 100],  # ctrl-left-arrow
            ord("A")          : ["one", "back", 100],
            ord("w")          : ["one", "back", 0],

            curses.KEY_RIGHT  : ["one", "forward", 1],  # right-arrow
            ord("d")          : ["one", "forward", 1],
            402               : ["one", "forward", 10],  # shf-right-arrow
            ord("f")          : ["one", "forward", 10],
            567               : ["one", "forward", 100],  # alt-shf-right-arrow
            561               : ["one", "forward", 100],  # ctrl-right-arrow
            ord("F")          : ["one", "forward", 100],
            ord("e")          : ["one", "forward", 0],

            curses.KEY_DOWN   : ["one", "window move", "down", "one"],
            ord("j")          : ["one", "window move", "down", "one"],
            4                 : ["one", "window move", "down", "half"],  # ctrl-d
            336               : ["one", "window move", "down", "page"],  # shift-down
            curses.KEY_NPAGE  : ["one", "window move", "down", "page"],  # page down
            6                 : ["one", "window move", "down", "page"],  # ctrl-f
            ord("G")          : ["one", "window move", "down", "bottom"],
            curses.KEY_END    : ["one", "window move", "down", "bottom"],
            526               : ["one", "window move", "down", "bottom"],  # ctrl-down

            curses.KEY_UP     : ["one", "window move", "up", "one"],
            ord("k")          : ["one", "window move", "up", "one"],
            21                : ["one", "window move", "up", "half"],  # ctrl-u
            337               : ["one", "window move", "up", "page"],  # shift-up
            curses.KEY_PPAGE  : ["one", "window move", "up", "page"],  # page up
            2                 : ["one", "window move", "up", "page"],  # ctrl-b
            ord("g")          : ["one", "window move", "up", "top"],
            curses.KEY_HOME   : ["one", "window move", "up", "top"],
            567               : ["one", "window move", "up", "top"],  # crtl-up

            ord("x")          : ["one", "toggle change"],
            ord("X")          : ["one", "clear history"]
        }
        self.tab_map = {ord("1"): 0, ord("2"): 1, ord("3"): 2, ord("4"): 3, ord("5"): 4, ord("6"): 5, ord("7"): 6,
                        ord("8"): 7, ord("9"): 8, ord("0"): 9, ord("!"): 10, ord("@"): 11, ord("#"): 12, ord("$"): 13,
                        ord("%"): 14, ord("^"): 15, ord("&"): 16, ord("*"): 17, ord("("): 18, ord(")"): 19,
                        8: Settings.window_id_help}
    def get_terminal_size(self):
        # need to refresh before getting size
        self.window.refresh()
        self.terminal_height, self.terminal_width = self.window.getmaxyx()

        Debug.debug_to_file("{} {}".format(self.terminal_height, self.terminal_width))

        # self.terminal_draw_height = self.terminal_height - self.draw_height_adder
        # self.terminal_draw_width = self.terminal_width - self.draw_width_adder

    def keyboard_input(self, raw_keystroke=0):
        self.window.nodelay(1)
        if raw_keystroke == 0:
            raw_keystroke = self.window.getch()

        if raw_keystroke != -1:
            # to see keystroke codes uncomment this line and tail -f debug on the commond line
            # Debug.debug_to_file("raw: " + str(raw_keystroke)  )
            pass

        if raw_keystroke == curses.KEY_RESIZE:
            # window resize event occurred
            # when a window is resized, a lot of events are fired once. We will delay a bit.
            # this also helps with redraw issues
            wait_time = .3
            self.resize_request = timeit.default_timer() + wait_time

        if self.draw_window_id == Settings.window_id_help:
            # when resizing, a lot of events are generated at once. wait a bit before sending
            if raw_keystroke == 8 or raw_keystroke == 27:
                # ctrl-h or [esc], toggle out of help. Fake a key press for the last tab
                raw_keystroke = [key for key, w_id in self.tab_map.items() if w_id == self.last_tab][0]

        if raw_keystroke in self.tab_map:
            # switch tabs
            new_win = self.tab_map[raw_keystroke]
            if Settings.commands[new_win] and new_win != self.draw_window_id:
                try:
                    self.event_queues[self.draw_window_id].put(("tab change", new_win, "close"), timeout=Settings.timeout)
                    self.last_tab = self.draw_window_id
                    self.draw_window_id = new_win
                    time.sleep(.1)
                    self.event_queues[self.draw_window_id].put(("tab change", new_win, "new"), timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        if raw_keystroke == ord("r") and not Settings.load_saved_run:
            # stop / start recording
            if self.recording_state == "record":
                self.recording_state = "stop"
                self.key_map[ord("r")] = ["all", "toggle recording", "stop"]
            else:
                self.recording_state = "record"
                self.key_map[ord("r")] = ["all", "toggle recording", "record"]
                self.new_stop_time = 0

        if raw_keystroke in self.key_map:
            # move, frames, etc
            if self.key_map[raw_keystroke][0] == "all":
                win = self.draw_window_ids
            else:
                win = [self.draw_window_id]
            instruction = self.key_map[raw_keystroke][1:]

            self.send_event(instruction, win)

        if raw_keystroke == 23:
            # ctrl-w
            self.write_to_file()

        # TODO sleeping processes are not quiting with q, so use ctrl-c for now
        if raw_keystroke == ord("q"):
            sys.exc_clear()
            # need to simulate a ctrl-c, otherwise sleeping processes won't exit on 'q'
            term_sig = 2
            try:
                os.killpg(os.getpgid(0), term_sig)
            except OSError:
                pass

    def send_event(self, instruction, win):
        for window_id in win:
            try:
                self.event_queues[window_id].put(instruction, timeout=Settings.timeout)
            except multiprocessing.queues.Full:
                pass

    def write_to_file(self):
        # first need to stop recording
        temp_recording_state = self.recording_state
        if self.recording_state == "record":
            self.recording_state = "stop"
            self.send_event(["toggle recording", "stop"], self.draw_window_ids)
            time.sleep(.1)

        # make a filename
        file_base = str(datetime.datetime.now().date()) + "-" + \
                   str(datetime.datetime.now().time()).split(".")[0].replace(":", "-") + \
                   ".wp"
        filename = file_base
        add_count = 0
        while True:
            if os.path.exists("{}/{}".format(Settings.run_path, filename)):
                add_count += 1
                filename = file_base.replace(".wp", "_" + str(add_count) + ".wp")
                continue
            break
        run_file = "{}/{}".format(Settings.run_path, filename)

        # write Setting
        try:
            if Settings.run_compression:
                with bz2.BZ2File(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
            else:
                with open(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
        except FileNotFoundError:
            # TODO add failed message, remove started file
            return
        except:
            # TODO add failed message
            return

        # tell each tab to write
        for window_id in self.draw_window_ids:
            self.send_event(["save", run_file], [window_id])
            get = 0
            for i in range(3 * 60 * 10):
                # get completed response(2), 3 minute timeout
                try:
                    get = int(self.system_queues[window_id].get(block=True, timeout=.1))
                    self.done_count += 1 if get == 1 else 0
                    if get == 2:
                        break
                except multiprocessing.queues.Empty:
                    pass
            if get != 2:
                # TODO add failed message
                return

        # turn recording back on
        if temp_recording_state == "record":
            self.recording_state = "record"
            self.new_stop_time = 0
            self.send_event(["toggle recording", "record"], self.draw_window_ids)

# ======================================================================================================================
#   Functions
# ======================================================================================================================

def new_sleep(stop_time):
    """ Curses sends a SIGWINCH to time.sleep and mp.Queue(timeout=) when the window is resized, which terminates them
        prematurely. To prevent this we must build our own timer. (This will not fix mp.Queue(timeout=))
        """
    stop = timeit.default_timer() + stop_time
    while stop >= timeit.default_timer():
        try:
            _sleep(max(0, stop - timeit.default_timer()))
        except ValueError:
            pass

def run_linux(command, stdout=subprocess.PIPE):
    result, error = subprocess.Popen(
        command,
        stdout=stdout,
        stderr=subprocess.PIPE,
        shell=True,
        universal_newlines=True).communicate()
    return result, error

def terminate_processes(message=None):
    exception = str(traceback.format_exc())
    terminate_curses()
    time.sleep(.1)
    if "KeyboardInterrupt" not in exception and "None\n" not in exception:
        print(exception)
    if message:
        print(message)
    term_sig = 15
    try:
        os.killpg(os.getpgid(0), term_sig)
    except (TypeError, OSError):
        pass

def terminate_curses():
    curses.echo()
    curses.nocbreak()
    curses.curs_set(1)
    curses.endwin()


# ======================================================================================================================
#   Main
# ======================================================================================================================

class Main(object):
    event_queues = [None] * MAX_TABS
    system_queues = [None] * MAX_TABS
    frame_draw_current_queue = multiprocessing.Value("i", 0)
    frame_draw_state_queue = multiprocessing.Value("i", 0)
    process_frame_controllers = [None] * MAX_TABS
    process_event_controller = None
    stdscr = None

    @classmethod
    def start_curses(cls):
        cls.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        cls.stdscr.keypad(True)
        curses.start_color()
        cls.curses_color_setup()

    @staticmethod
    def curses_color_setup():
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_BLUE)
        curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(31, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(32, curses.COLOR_BLACK, curses.COLOR_CYAN)
        curses.init_pair(33, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(34, curses.COLOR_BLACK, curses.COLOR_RED)

    @classmethod
    def spawn_frame_controllers(cls):
        for window_id in Settings.window_ids:
            cls.spawn_frame_controller(window_id, Settings._frame_controller_seeds[window_id])

    @classmethod
    def spawn_frame_controller(cls, window_id, frame_controller_seed):
        cls.event_queues[window_id] = multiprocessing.Queue(0)
        cls.system_queues[window_id] = multiprocessing.Queue(0)
        cls.process_frame_controllers[window_id] = multiprocessing.Process(
            target=frame_controller_seed.frame_controller,
            args=(
                window_id,
                cls.event_queues[window_id],
                cls.system_queues[window_id],
                cls.frame_draw_current_queue,
                cls.frame_draw_state_queue
        ))

    @classmethod
    def start_frame_controllers(cls):
        for window_id in Settings.window_ids:
            cls.process_frame_controllers[window_id].start()

    @classmethod
    def main_controller(cls):
        event_controller_seed = EventController()
        cls.process_event_controller = multiprocessing.Process(
            target=event_controller_seed.event_controller,
            args=(
                cls.stdscr,
                cls.event_queues,
                cls.system_queues
            ))
        cls.process_event_controller.start()
        cls.process_event_controller.join()

class MainSavedRun(Main):

    @classmethod
    def start_frame_controllers(cls):
        if Settings.run_compression:
            with bz2.BZ2File(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(run_file)
        else:
            with open(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(run_file)

    @classmethod
    def load_pickle(cls, run_file):
        try:
            # load Settings first
            pickle.load(run_file, fix_imports=True)
            Settings.load_saved_run = True
            Settings.start_window_id = Settings.window_ids[0]
            # we need to rebuild help tab, as we don't want to use the saved help
            Settings._setup_help()

            # load frames
            for window_id in Settings.window_ids:
                if window_id == Settings.window_id_help:
                    # we will load in the help separately, as it is not from the saved group)
                    cls.spawn_frame_controller(Settings.window_id_help,
                                               Settings._frame_controller_seeds[Settings.window_id_help])
                else:
                    # if we load data into a FrameController instance, then spawn the processes from that instance,
                    # the instance data will be copied into the new processes
                    frame_controller = pickle.load(run_file, fix_imports=True)

                    # convert loaded class instance (FrameController) to a saved instance (FrameControllerSavedRun)
                    frame_controller_seed = FrameControllersSavedRun()
                    frame_controller_seed.__dict__.update(frame_controller.__dict__)
                    del frame_controller

                    cls.spawn_frame_controller(window_id, frame_controller)
                    del frame_controller_seed

            # add help tab

        except EOFError:
            # not enough items to read in
            # make a better error message
            raise

if __name__ == "__main__":

    # make our own custom sleep
    time.sleep = new_sleep

    process_argparse()

    try:
        if Settings.load_saved_run:
            main = MainSavedRun()
        else:
            main = Main()
        main.start_curses()
        main.spawn_frame_controllers()
        main.start_frame_controllers()
        main.main_controller()
    except:
        terminate_processes()
